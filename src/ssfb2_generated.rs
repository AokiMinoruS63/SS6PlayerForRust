// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod ss {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod ssfb_2 {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_MODEL_PARTS_KIND_FEATURE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_MODEL_PARTS_KIND_FEATURE: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_MODEL_PARTS_KIND_FEATURE: [DataModelPartsKindFeature; 13] = [
  DataModelPartsKindFeature::Root,
  DataModelPartsKindFeature::Null,
  DataModelPartsKindFeature::Normal,
  DataModelPartsKindFeature::Instance,
  DataModelPartsKindFeature::Effect,
  DataModelPartsKindFeature::Mask,
  DataModelPartsKindFeature::Joint,
  DataModelPartsKindFeature::Bone,
  DataModelPartsKindFeature::MoveNode,
  DataModelPartsKindFeature::Constraint,
  DataModelPartsKindFeature::BonePoint,
  DataModelPartsKindFeature::Mesh,
  DataModelPartsKindFeature::Terminator,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataModelPartsKindFeature(pub u8);
#[allow(non_upper_case_globals)]
impl DataModelPartsKindFeature {
  pub const Root: Self = Self(0);
  pub const Null: Self = Self(1);
  pub const Normal: Self = Self(2);
  pub const Instance: Self = Self(3);
  pub const Effect: Self = Self(4);
  pub const Mask: Self = Self(5);
  pub const Joint: Self = Self(6);
  pub const Bone: Self = Self(7);
  pub const MoveNode: Self = Self(8);
  pub const Constraint: Self = Self(9);
  pub const BonePoint: Self = Self(10);
  pub const Mesh: Self = Self(11);
  pub const Terminator: Self = Self(12);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Root,
    Self::Null,
    Self::Normal,
    Self::Instance,
    Self::Effect,
    Self::Mask,
    Self::Joint,
    Self::Bone,
    Self::MoveNode,
    Self::Constraint,
    Self::BonePoint,
    Self::Mesh,
    Self::Terminator,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Root => Some("Root"),
      Self::Null => Some("Null"),
      Self::Normal => Some("Normal"),
      Self::Instance => Some("Instance"),
      Self::Effect => Some("Effect"),
      Self::Mask => Some("Mask"),
      Self::Joint => Some("Joint"),
      Self::Bone => Some("Bone"),
      Self::MoveNode => Some("MoveNode"),
      Self::Constraint => Some("Constraint"),
      Self::BonePoint => Some("BonePoint"),
      Self::Mesh => Some("Mesh"),
      Self::Terminator => Some("Terminator"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DataModelPartsKindFeature {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DataModelPartsKindFeature {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DataModelPartsKindFeature {
    type Output = DataModelPartsKindFeature;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataModelPartsKindFeature {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DataModelPartsKindFeature {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DataModelPartsKindFeature {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KIND_COLLISION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KIND_COLLISION: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KIND_COLLISION: [KindCollision; 6] = [
  KindCollision::Non,
  KindCollision::Square,
  KindCollision::Aabb,
  KindCollision::Circle,
  KindCollision::CircleScaleMinimum,
  KindCollision::CircleScaleMaximum,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KindCollision(pub u8);
#[allow(non_upper_case_globals)]
impl KindCollision {
  pub const Non: Self = Self(0);
  pub const Square: Self = Self(1);
  pub const Aabb: Self = Self(2);
  pub const Circle: Self = Self(3);
  pub const CircleScaleMinimum: Self = Self(4);
  pub const CircleScaleMaximum: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Non,
    Self::Square,
    Self::Aabb,
    Self::Circle,
    Self::CircleScaleMinimum,
    Self::CircleScaleMaximum,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Non => Some("Non"),
      Self::Square => Some("Square"),
      Self::Aabb => Some("Aabb"),
      Self::Circle => Some("Circle"),
      Self::CircleScaleMinimum => Some("CircleScaleMinimum"),
      Self::CircleScaleMaximum => Some("CircleScaleMaximum"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KindCollision {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KindCollision {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KindCollision {
    type Output = KindCollision;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KindCollision {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KindCollision {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KindCollision {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COLOR_LABEL_KIND_FORM: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COLOR_LABEL_KIND_FORM: u8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COLOR_LABEL_KIND_FORM: [ColorLabelKindForm; 9] = [
  ColorLabelKindForm::Non,
  ColorLabelKindForm::Red,
  ColorLabelKindForm::Orange,
  ColorLabelKindForm::Yellow,
  ColorLabelKindForm::Green,
  ColorLabelKindForm::Blue,
  ColorLabelKindForm::Violet,
  ColorLabelKindForm::Gray,
  ColorLabelKindForm::Terminator,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ColorLabelKindForm(pub u8);
#[allow(non_upper_case_globals)]
impl ColorLabelKindForm {
  pub const Non: Self = Self(0);
  pub const Red: Self = Self(1);
  pub const Orange: Self = Self(2);
  pub const Yellow: Self = Self(3);
  pub const Green: Self = Self(4);
  pub const Blue: Self = Self(5);
  pub const Violet: Self = Self(6);
  pub const Gray: Self = Self(7);
  pub const Terminator: Self = Self(8);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Non,
    Self::Red,
    Self::Orange,
    Self::Yellow,
    Self::Green,
    Self::Blue,
    Self::Violet,
    Self::Gray,
    Self::Terminator,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Non => Some("Non"),
      Self::Red => Some("Red"),
      Self::Orange => Some("Orange"),
      Self::Yellow => Some("Yellow"),
      Self::Green => Some("Green"),
      Self::Blue => Some("Blue"),
      Self::Violet => Some("Violet"),
      Self::Gray => Some("Gray"),
      Self::Terminator => Some("Terminator"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ColorLabelKindForm {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ColorLabelKindForm {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ColorLabelKindForm {
    type Output = ColorLabelKindForm;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ColorLabelKindForm {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ColorLabelKindForm {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ColorLabelKindForm {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KIND_OPERATION_BLEND: i8 = -2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KIND_OPERATION_BLEND: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KIND_OPERATION_BLEND: [KindOperationBlend; 11] = [
  KindOperationBlend::MaskPre,
  KindOperationBlend::Mask,
  KindOperationBlend::Mix,
  KindOperationBlend::Add,
  KindOperationBlend::Sub,
  KindOperationBlend::Mul,
  KindOperationBlend::MulNa,
  KindOperationBlend::Scr,
  KindOperationBlend::Exc,
  KindOperationBlend::Inv,
  KindOperationBlend::Terminator,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KindOperationBlend(pub i8);
#[allow(non_upper_case_globals)]
impl KindOperationBlend {
  pub const MaskPre: Self = Self(-2);
  pub const Mask: Self = Self(-1);
  pub const Mix: Self = Self(0);
  pub const Add: Self = Self(1);
  pub const Sub: Self = Self(2);
  pub const Mul: Self = Self(3);
  pub const MulNa: Self = Self(4);
  pub const Scr: Self = Self(5);
  pub const Exc: Self = Self(6);
  pub const Inv: Self = Self(7);
  pub const Terminator: Self = Self(8);

  pub const ENUM_MIN: i8 = -2;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MaskPre,
    Self::Mask,
    Self::Mix,
    Self::Add,
    Self::Sub,
    Self::Mul,
    Self::MulNa,
    Self::Scr,
    Self::Exc,
    Self::Inv,
    Self::Terminator,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MaskPre => Some("MaskPre"),
      Self::Mask => Some("Mask"),
      Self::Mix => Some("Mix"),
      Self::Add => Some("Add"),
      Self::Sub => Some("Sub"),
      Self::Mul => Some("Mul"),
      Self::MulNa => Some("MulNa"),
      Self::Scr => Some("Scr"),
      Self::Exc => Some("Exc"),
      Self::Inv => Some("Inv"),
      Self::Terminator => Some("Terminator"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KindOperationBlend {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KindOperationBlend {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KindOperationBlend {
    type Output = KindOperationBlend;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KindOperationBlend {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KindOperationBlend {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KindOperationBlend {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KIND_MODE_SORT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KIND_MODE_SORT: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KIND_MODE_SORT: [KindModeSort; 2] = [
  KindModeSort::Priority,
  KindModeSort::PositionZ,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KindModeSort(pub u8);
#[allow(non_upper_case_globals)]
impl KindModeSort {
  pub const Priority: Self = Self(0);
  pub const PositionZ: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Priority,
    Self::PositionZ,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Priority => Some("Priority"),
      Self::PositionZ => Some("PositionZ"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KindModeSort {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KindModeSort {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KindModeSort {
    type Output = KindModeSort;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KindModeSort {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KindModeSort {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KindModeSort {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_ANIMATION_PARTS_FLAG_BIT_STATUS: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_ANIMATION_PARTS_FLAG_BIT_STATUS: u32 = 1073741824;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_ANIMATION_PARTS_FLAG_BIT_STATUS: [DataAnimationPartsFlagBitStatus; 13] = [
  DataAnimationPartsFlagBitStatus::Clear,
  DataAnimationPartsFlagBitStatus::NoEffect,
  DataAnimationPartsFlagBitStatus::NoInstance,
  DataAnimationPartsFlagBitStatus::NoPartsColor,
  DataAnimationPartsFlagBitStatus::NoUserData,
  DataAnimationPartsFlagBitStatus::NoTransformationTexture,
  DataAnimationPartsFlagBitStatus::NoScaling,
  DataAnimationPartsFlagBitStatus::NoRotation,
  DataAnimationPartsFlagBitStatus::NoPosition,
  DataAnimationPartsFlagBitStatus::NotMasking,
  DataAnimationPartsFlagBitStatus::HideFull,
  DataAnimationPartsFlagBitStatus::NotUsed,
  DataAnimationPartsFlagBitStatus::Valid,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataAnimationPartsFlagBitStatus(pub u32);
#[allow(non_upper_case_globals)]
impl DataAnimationPartsFlagBitStatus {
  pub const Clear: Self = Self(0);
  pub const NoEffect: Self = Self(65536);
  pub const NoInstance: Self = Self(131072);
  pub const NoPartsColor: Self = Self(262144);
  pub const NoUserData: Self = Self(524288);
  pub const NoTransformationTexture: Self = Self(1048576);
  pub const NoScaling: Self = Self(2097152);
  pub const NoRotation: Self = Self(4194304);
  pub const NoPosition: Self = Self(8388608);
  pub const NotMasking: Self = Self(134217728);
  pub const HideFull: Self = Self(268435456);
  pub const NotUsed: Self = Self(536870912);
  pub const Valid: Self = Self(1073741824);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 1073741824;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Clear,
    Self::NoEffect,
    Self::NoInstance,
    Self::NoPartsColor,
    Self::NoUserData,
    Self::NoTransformationTexture,
    Self::NoScaling,
    Self::NoRotation,
    Self::NoPosition,
    Self::NotMasking,
    Self::HideFull,
    Self::NotUsed,
    Self::Valid,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Clear => Some("Clear"),
      Self::NoEffect => Some("NoEffect"),
      Self::NoInstance => Some("NoInstance"),
      Self::NoPartsColor => Some("NoPartsColor"),
      Self::NoUserData => Some("NoUserData"),
      Self::NoTransformationTexture => Some("NoTransformationTexture"),
      Self::NoScaling => Some("NoScaling"),
      Self::NoRotation => Some("NoRotation"),
      Self::NoPosition => Some("NoPosition"),
      Self::NotMasking => Some("NotMasking"),
      Self::HideFull => Some("HideFull"),
      Self::NotUsed => Some("NotUsed"),
      Self::Valid => Some("Valid"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DataAnimationPartsFlagBitStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DataAnimationPartsFlagBitStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DataAnimationPartsFlagBitStatus {
    type Output = DataAnimationPartsFlagBitStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataAnimationPartsFlagBitStatus {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DataAnimationPartsFlagBitStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DataAnimationPartsFlagBitStatus {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KIND_OPERATION_BLEND_EFFECT: i8 = -1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KIND_OPERATION_BLEND_EFFECT: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KIND_OPERATION_BLEND_EFFECT: [KindOperationBlendEffect; 4] = [
  KindOperationBlendEffect::Non,
  KindOperationBlendEffect::Mix,
  KindOperationBlendEffect::Add,
  KindOperationBlendEffect::Terminator,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KindOperationBlendEffect(pub i8);
#[allow(non_upper_case_globals)]
impl KindOperationBlendEffect {
  pub const Non: Self = Self(-1);
  pub const Mix: Self = Self(0);
  pub const Add: Self = Self(1);
  pub const Terminator: Self = Self(2);

  pub const ENUM_MIN: i8 = -1;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Non,
    Self::Mix,
    Self::Add,
    Self::Terminator,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Non => Some("Non"),
      Self::Mix => Some("Mix"),
      Self::Add => Some("Add"),
      Self::Terminator => Some("Terminator"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KindOperationBlendEffect {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KindOperationBlendEffect {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KindOperationBlendEffect {
    type Output = KindOperationBlendEffect;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KindOperationBlendEffect {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KindOperationBlendEffect {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KindOperationBlendEffect {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KIND_TYPE_PACK: i16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KIND_TYPE_PACK: i16 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KIND_TYPE_PACK: [KindTypePack; 5] = [
  KindTypePack::STANDARD_UNCOMPRESSED,
  KindTypePack::STANDARD_CPE,
  KindTypePack::CPE_FLYWEIGHT,
  KindTypePack::CPE_INTERPOLATE,
  KindTypePack::TERMINATOR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KindTypePack(pub i16);
#[allow(non_upper_case_globals)]
impl KindTypePack {
  pub const STANDARD_UNCOMPRESSED: Self = Self(0);
  pub const STANDARD_CPE: Self = Self(1);
  pub const CPE_FLYWEIGHT: Self = Self(2);
  pub const CPE_INTERPOLATE: Self = Self(3);
  pub const TERMINATOR: Self = Self(4);

  pub const ENUM_MIN: i16 = 0;
  pub const ENUM_MAX: i16 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::STANDARD_UNCOMPRESSED,
    Self::STANDARD_CPE,
    Self::CPE_FLYWEIGHT,
    Self::CPE_INTERPOLATE,
    Self::TERMINATOR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::STANDARD_UNCOMPRESSED => Some("STANDARD_UNCOMPRESSED"),
      Self::STANDARD_CPE => Some("STANDARD_CPE"),
      Self::CPE_FLYWEIGHT => Some("CPE_FLYWEIGHT"),
      Self::CPE_INTERPOLATE => Some("CPE_INTERPOLATE"),
      Self::TERMINATOR => Some("TERMINATOR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KindTypePack {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KindTypePack {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i16>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KindTypePack {
    type Output = KindTypePack;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KindTypePack {
  type Scalar = i16;
  #[inline]
  fn to_little_endian(self) -> i16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i16) -> Self {
    let b = i16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KindTypePack {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KindTypePack {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_USER_DATA_FLAG_BIT: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_USER_DATA_FLAG_BIT: u32 = 1073741824;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_USER_DATA_FLAG_BIT: [UserDataFlagBit; 6] = [
  UserDataFlagBit::CLEAR,
  UserDataFlagBit::NUMBER,
  UserDataFlagBit::RECTANGLE,
  UserDataFlagBit::COORDINATE,
  UserDataFlagBit::TEXT,
  UserDataFlagBit::VALID,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct UserDataFlagBit(pub u32);
#[allow(non_upper_case_globals)]
impl UserDataFlagBit {
  pub const CLEAR: Self = Self(0);
  pub const NUMBER: Self = Self(1);
  pub const RECTANGLE: Self = Self(2);
  pub const COORDINATE: Self = Self(4);
  pub const TEXT: Self = Self(8);
  pub const VALID: Self = Self(1073741824);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 1073741824;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CLEAR,
    Self::NUMBER,
    Self::RECTANGLE,
    Self::COORDINATE,
    Self::TEXT,
    Self::VALID,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CLEAR => Some("CLEAR"),
      Self::NUMBER => Some("NUMBER"),
      Self::RECTANGLE => Some("RECTANGLE"),
      Self::COORDINATE => Some("COORDINATE"),
      Self::TEXT => Some("TEXT"),
      Self::VALID => Some("VALID"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for UserDataFlagBit {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for UserDataFlagBit {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for UserDataFlagBit {
    type Output = UserDataFlagBit;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for UserDataFlagBit {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for UserDataFlagBit {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for UserDataFlagBit {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_EFFECT_FLAG_BIT: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_EFFECT_FLAG_BIT: u32 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_EFFECT_FLAG_BIT: [DataEffectFlagBit; 2] = [
  DataEffectFlagBit::Clear,
  DataEffectFlagBit::SeedRandomLock,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataEffectFlagBit(pub u32);
#[allow(non_upper_case_globals)]
impl DataEffectFlagBit {
  pub const Clear: Self = Self(0);
  pub const SeedRandomLock: Self = Self(1);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Clear,
    Self::SeedRandomLock,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Clear => Some("Clear"),
      Self::SeedRandomLock => Some("SeedRandomLock"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DataEffectFlagBit {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DataEffectFlagBit {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DataEffectFlagBit {
    type Output = DataEffectFlagBit;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataEffectFlagBit {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DataEffectFlagBit {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DataEffectFlagBit {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_EFFECT_PARTS_KIND_FEATURE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_EFFECT_PARTS_KIND_FEATURE: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_EFFECT_PARTS_KIND_FEATURE: [DataEffectPartsKindFeature; 4] = [
  DataEffectPartsKindFeature::Root,
  DataEffectPartsKindFeature::Emitter,
  DataEffectPartsKindFeature::Particle,
  DataEffectPartsKindFeature::Terminator,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataEffectPartsKindFeature(pub u8);
#[allow(non_upper_case_globals)]
impl DataEffectPartsKindFeature {
  pub const Root: Self = Self(0);
  pub const Emitter: Self = Self(1);
  pub const Particle: Self = Self(2);
  pub const Terminator: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Root,
    Self::Emitter,
    Self::Particle,
    Self::Terminator,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Root => Some("Root"),
      Self::Emitter => Some("Emitter"),
      Self::Particle => Some("Particle"),
      Self::Terminator => Some("Terminator"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DataEffectPartsKindFeature {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DataEffectPartsKindFeature {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DataEffectPartsKindFeature {
    type Output = DataEffectPartsKindFeature;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataEffectPartsKindFeature {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DataEffectPartsKindFeature {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DataEffectPartsKindFeature {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_EFFECT_EMITTER_FLAG_BIT: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_EFFECT_EMITTER_FLAG_BIT: u32 = 2147483647;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_EFFECT_EMITTER_FLAG_BIT: [DataEffectEmitterFlagBit; 23] = [
  DataEffectEmitterFlagBit::Clear,
  DataEffectEmitterFlagBit::Basic,
  DataEffectEmitterFlagBit::TangentialAccelation,
  DataEffectEmitterFlagBit::TurnDirection,
  DataEffectEmitterFlagBit::SeedRandom,
  DataEffectEmitterFlagBit::Delay,
  DataEffectEmitterFlagBit::Position,
  DataEffectEmitterFlagBit::PositionFluctuation,
  DataEffectEmitterFlagBit::Rotation,
  DataEffectEmitterFlagBit::RotationFluctuation,
  DataEffectEmitterFlagBit::ScaleStart,
  DataEffectEmitterFlagBit::ScaleEnd,
  DataEffectEmitterFlagBit::Speed,
  DataEffectEmitterFlagBit::SpeedFluctuation,
  DataEffectEmitterFlagBit::GravityDirection,
  DataEffectEmitterFlagBit::GravityPoint,
  DataEffectEmitterFlagBit::ColorVertex,
  DataEffectEmitterFlagBit::ColorVertexFluctuation,
  DataEffectEmitterFlagBit::FadeAlpha,
  DataEffectEmitterFlagBit::MaskParticle,
  DataEffectEmitterFlagBit::EmitInfinite,
  DataEffectEmitterFlagBit::MaskEmitter,
  DataEffectEmitterFlagBit::MaskValid,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataEffectEmitterFlagBit(pub u32);
#[allow(non_upper_case_globals)]
impl DataEffectEmitterFlagBit {
  pub const Clear: Self = Self(0);
  pub const Basic: Self = Self(1);
  pub const TangentialAccelation: Self = Self(2);
  pub const TurnDirection: Self = Self(4);
  pub const SeedRandom: Self = Self(8);
  pub const Delay: Self = Self(16);
  pub const Position: Self = Self(256);
  pub const PositionFluctuation: Self = Self(512);
  pub const Rotation: Self = Self(1024);
  pub const RotationFluctuation: Self = Self(2048);
  pub const ScaleStart: Self = Self(4096);
  pub const ScaleEnd: Self = Self(8192);
  pub const Speed: Self = Self(65536);
  pub const SpeedFluctuation: Self = Self(131072);
  pub const GravityDirection: Self = Self(262144);
  pub const GravityPoint: Self = Self(524288);
  pub const ColorVertex: Self = Self(1048576);
  pub const ColorVertexFluctuation: Self = Self(2097152);
  pub const FadeAlpha: Self = Self(4194304);
  pub const MaskParticle: Self = Self(16777215);
  pub const EmitInfinite: Self = Self(16777216);
  pub const MaskEmitter: Self = Self(2130706432);
  pub const MaskValid: Self = Self(2147483647);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 2147483647;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Clear,
    Self::Basic,
    Self::TangentialAccelation,
    Self::TurnDirection,
    Self::SeedRandom,
    Self::Delay,
    Self::Position,
    Self::PositionFluctuation,
    Self::Rotation,
    Self::RotationFluctuation,
    Self::ScaleStart,
    Self::ScaleEnd,
    Self::Speed,
    Self::SpeedFluctuation,
    Self::GravityDirection,
    Self::GravityPoint,
    Self::ColorVertex,
    Self::ColorVertexFluctuation,
    Self::FadeAlpha,
    Self::MaskParticle,
    Self::EmitInfinite,
    Self::MaskEmitter,
    Self::MaskValid,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Clear => Some("Clear"),
      Self::Basic => Some("Basic"),
      Self::TangentialAccelation => Some("TangentialAccelation"),
      Self::TurnDirection => Some("TurnDirection"),
      Self::SeedRandom => Some("SeedRandom"),
      Self::Delay => Some("Delay"),
      Self::Position => Some("Position"),
      Self::PositionFluctuation => Some("PositionFluctuation"),
      Self::Rotation => Some("Rotation"),
      Self::RotationFluctuation => Some("RotationFluctuation"),
      Self::ScaleStart => Some("ScaleStart"),
      Self::ScaleEnd => Some("ScaleEnd"),
      Self::Speed => Some("Speed"),
      Self::SpeedFluctuation => Some("SpeedFluctuation"),
      Self::GravityDirection => Some("GravityDirection"),
      Self::GravityPoint => Some("GravityPoint"),
      Self::ColorVertex => Some("ColorVertex"),
      Self::ColorVertexFluctuation => Some("ColorVertexFluctuation"),
      Self::FadeAlpha => Some("FadeAlpha"),
      Self::MaskParticle => Some("MaskParticle"),
      Self::EmitInfinite => Some("EmitInfinite"),
      Self::MaskEmitter => Some("MaskEmitter"),
      Self::MaskValid => Some("MaskValid"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DataEffectEmitterFlagBit {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DataEffectEmitterFlagBit {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DataEffectEmitterFlagBit {
    type Output = DataEffectEmitterFlagBit;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataEffectEmitterFlagBit {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DataEffectEmitterFlagBit {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DataEffectEmitterFlagBit {}
pub enum Vector2Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Vector2<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Vector2<'a> {
  type Inner = Vector2<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Vector2<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Vector2 { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Vector2Args
  ) -> flatbuffers::WIPOffset<Vector2<'bldr>> {
    let mut builder = Vector2Builder::new(_fbb);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.finish()
  }


  #[inline]
  pub fn x(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Vector2::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Vector2::VT_Y, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Vector2<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("x", Self::VT_X, false)?
     .visit_field::<f32>("y", Self::VT_Y, false)?
     .finish();
    Ok(())
  }
}
pub struct Vector2Args {
    pub x: f32,
    pub y: f32,
}
impl<'a> Default for Vector2Args {
  #[inline]
  fn default() -> Self {
    Vector2Args {
      x: 0.0,
      y: 0.0,
    }
  }
}

pub struct Vector2Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Vector2Builder<'a, 'b, A> {
  #[inline]
  pub fn add_x(&mut self, x: f32) {
    self.fbb_.push_slot::<f32>(Vector2::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f32) {
    self.fbb_.push_slot::<f32>(Vector2::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Vector2Builder<'a, 'b, A> {
    let start = _fbb.start_table();
    Vector2Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Vector2<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Vector2<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Vector2");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.finish()
  }
}
pub enum Vector3Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Vector3<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Vector3<'a> {
  type Inner = Vector3<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Vector3<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;
  pub const VT_Z: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Vector3 { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Vector3Args
  ) -> flatbuffers::WIPOffset<Vector3<'bldr>> {
    let mut builder = Vector3Builder::new(_fbb);
    builder.add_z(args.z);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.finish()
  }


  #[inline]
  pub fn x(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Vector3::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Vector3::VT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn z(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Vector3::VT_Z, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Vector3<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("x", Self::VT_X, false)?
     .visit_field::<f32>("y", Self::VT_Y, false)?
     .visit_field::<f32>("z", Self::VT_Z, false)?
     .finish();
    Ok(())
  }
}
pub struct Vector3Args {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
impl<'a> Default for Vector3Args {
  #[inline]
  fn default() -> Self {
    Vector3Args {
      x: 0.0,
      y: 0.0,
      z: 0.0,
    }
  }
}

pub struct Vector3Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Vector3Builder<'a, 'b, A> {
  #[inline]
  pub fn add_x(&mut self, x: f32) {
    self.fbb_.push_slot::<f32>(Vector3::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f32) {
    self.fbb_.push_slot::<f32>(Vector3::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn add_z(&mut self, z: f32) {
    self.fbb_.push_slot::<f32>(Vector3::VT_Z, z, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Vector3Builder<'a, 'b, A> {
    let start = _fbb.start_table();
    Vector3Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Vector3<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Vector3<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Vector3");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("z", &self.z());
      ds.finish()
  }
}
pub enum RectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Rect<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Rect<'a> {
  type Inner = Rect<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Rect<'a> {
  pub const VT_X_MIN: flatbuffers::VOffsetT = 4;
  pub const VT_Y_MIN: flatbuffers::VOffsetT = 6;
  pub const VT_X_MAX: flatbuffers::VOffsetT = 8;
  pub const VT_Y_MAX: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Rect { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RectArgs
  ) -> flatbuffers::WIPOffset<Rect<'bldr>> {
    let mut builder = RectBuilder::new(_fbb);
    builder.add_y_max(args.y_max);
    builder.add_x_max(args.x_max);
    builder.add_y_min(args.y_min);
    builder.add_x_min(args.x_min);
    builder.finish()
  }


  #[inline]
  pub fn x_min(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Rect::VT_X_MIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y_min(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Rect::VT_Y_MIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn x_max(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Rect::VT_X_MAX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y_max(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Rect::VT_Y_MAX, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Rect<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("x_min", Self::VT_X_MIN, false)?
     .visit_field::<f32>("y_min", Self::VT_Y_MIN, false)?
     .visit_field::<f32>("x_max", Self::VT_X_MAX, false)?
     .visit_field::<f32>("y_max", Self::VT_Y_MAX, false)?
     .finish();
    Ok(())
  }
}
pub struct RectArgs {
    pub x_min: f32,
    pub y_min: f32,
    pub x_max: f32,
    pub y_max: f32,
}
impl<'a> Default for RectArgs {
  #[inline]
  fn default() -> Self {
    RectArgs {
      x_min: 0.0,
      y_min: 0.0,
      x_max: 0.0,
      y_max: 0.0,
    }
  }
}

pub struct RectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RectBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x_min(&mut self, x_min: f32) {
    self.fbb_.push_slot::<f32>(Rect::VT_X_MIN, x_min, 0.0);
  }
  #[inline]
  pub fn add_y_min(&mut self, y_min: f32) {
    self.fbb_.push_slot::<f32>(Rect::VT_Y_MIN, y_min, 0.0);
  }
  #[inline]
  pub fn add_x_max(&mut self, x_max: f32) {
    self.fbb_.push_slot::<f32>(Rect::VT_X_MAX, x_max, 0.0);
  }
  #[inline]
  pub fn add_y_max(&mut self, y_max: f32) {
    self.fbb_.push_slot::<f32>(Rect::VT_Y_MAX, y_max, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RectBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Rect<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Rect<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Rect");
      ds.field("x_min", &self.x_min());
      ds.field("y_min", &self.y_min());
      ds.field("x_max", &self.x_max());
      ds.field("y_max", &self.y_max());
      ds.finish()
  }
}
pub enum DataMeshOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataMesh<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataMesh<'a> {
  type Inner = DataMesh<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataMesh<'a> {
  pub const VT_TABLE_COORDINATE: flatbuffers::VOffsetT = 4;
  pub const VT_TABLE_INDEX_VERTEX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataMesh { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataMeshArgs<'args>
  ) -> flatbuffers::WIPOffset<DataMesh<'bldr>> {
    let mut builder = DataMeshBuilder::new(_fbb);
    if let Some(x) = args.table_index_vertex { builder.add_table_index_vertex(x); }
    if let Some(x) = args.table_coordinate { builder.add_table_coordinate(x); }
    builder.finish()
  }


  #[inline]
  pub fn table_coordinate(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2>>>>(DataMesh::VT_TABLE_COORDINATE, None)}
  }
  #[inline]
  pub fn table_index_vertex(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(DataMesh::VT_TABLE_INDEX_VERTEX, None)}
  }
}

impl flatbuffers::Verifiable for DataMesh<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Vector2>>>>("table_coordinate", Self::VT_TABLE_COORDINATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_index_vertex", Self::VT_TABLE_INDEX_VERTEX, false)?
     .finish();
    Ok(())
  }
}
pub struct DataMeshArgs<'a> {
    pub table_coordinate: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2<'a>>>>>,
    pub table_index_vertex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for DataMeshArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataMeshArgs {
      table_coordinate: None,
      table_index_vertex: None,
    }
  }
}

pub struct DataMeshBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataMeshBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_table_coordinate(&mut self, table_coordinate: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Vector2<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataMesh::VT_TABLE_COORDINATE, table_coordinate);
  }
  #[inline]
  pub fn add_table_index_vertex(&mut self, table_index_vertex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataMesh::VT_TABLE_INDEX_VERTEX, table_index_vertex);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataMeshBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataMeshBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataMesh<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataMesh<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataMesh");
      ds.field("table_coordinate", &self.table_coordinate());
      ds.field("table_index_vertex", &self.table_index_vertex());
      ds.finish()
  }
}
pub enum CellOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Cell<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Cell<'a> {
  type Inner = Cell<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Cell<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_RECTANGLE: flatbuffers::VOffsetT = 6;
  pub const VT_PIVOT: flatbuffers::VOffsetT = 8;
  pub const VT_MESH: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Cell { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CellArgs<'args>
  ) -> flatbuffers::WIPOffset<Cell<'bldr>> {
    let mut builder = CellBuilder::new(_fbb);
    if let Some(x) = args.mesh { builder.add_mesh(x); }
    if let Some(x) = args.pivot { builder.add_pivot(x); }
    if let Some(x) = args.rectangle { builder.add_rectangle(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Cell::VT_NAME, None)}
  }
  #[inline]
  pub fn rectangle(&self) -> Option<Rect<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Rect>>(Cell::VT_RECTANGLE, None)}
  }
  #[inline]
  pub fn pivot(&self) -> Option<Vector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Vector2>>(Cell::VT_PIVOT, None)}
  }
  #[inline]
  pub fn mesh(&self) -> Option<DataMesh<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DataMesh>>(Cell::VT_MESH, None)}
  }
}

impl flatbuffers::Verifiable for Cell<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Rect>>("rectangle", Self::VT_RECTANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Vector2>>("pivot", Self::VT_PIVOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DataMesh>>("mesh", Self::VT_MESH, false)?
     .finish();
    Ok(())
  }
}
pub struct CellArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rectangle: Option<flatbuffers::WIPOffset<Rect<'a>>>,
    pub pivot: Option<flatbuffers::WIPOffset<Vector2<'a>>>,
    pub mesh: Option<flatbuffers::WIPOffset<DataMesh<'a>>>,
}
impl<'a> Default for CellArgs<'a> {
  #[inline]
  fn default() -> Self {
    CellArgs {
      name: None,
      rectangle: None,
      pivot: None,
      mesh: None,
    }
  }
}

pub struct CellBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CellBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Cell::VT_NAME, name);
  }
  #[inline]
  pub fn add_rectangle(&mut self, rectangle: flatbuffers::WIPOffset<Rect<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Rect>>(Cell::VT_RECTANGLE, rectangle);
  }
  #[inline]
  pub fn add_pivot(&mut self, pivot: flatbuffers::WIPOffset<Vector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vector2>>(Cell::VT_PIVOT, pivot);
  }
  #[inline]
  pub fn add_mesh(&mut self, mesh: flatbuffers::WIPOffset<DataMesh<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DataMesh>>(Cell::VT_MESH, mesh);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CellBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CellBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Cell<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Cell<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Cell");
      ds.field("name", &self.name());
      ds.field("rectangle", &self.rectangle());
      ds.field("pivot", &self.pivot());
      ds.field("mesh", &self.mesh());
      ds.finish()
  }
}
pub enum LibraryDataCellMapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LibraryDataCellMap<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LibraryDataCellMap<'a> {
  type Inner = LibraryDataCellMap<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LibraryDataCellMap<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SIZE_ORIGINAL: flatbuffers::VOffsetT = 6;
  pub const VT_FILTER: flatbuffers::VOffsetT = 8;
  pub const VT_WRAP: flatbuffers::VOffsetT = 10;
  pub const VT_TABLE_CELL: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LibraryDataCellMap { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LibraryDataCellMapArgs<'args>
  ) -> flatbuffers::WIPOffset<LibraryDataCellMap<'bldr>> {
    let mut builder = LibraryDataCellMapBuilder::new(_fbb);
    if let Some(x) = args.table_cell { builder.add_table_cell(x); }
    if let Some(x) = args.size_original { builder.add_size_original(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_wrap(args.wrap);
    builder.add_filter(args.filter);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LibraryDataCellMap::VT_NAME, None)}
  }
  #[inline]
  pub fn size_original(&self) -> Option<Vector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Vector2>>(LibraryDataCellMap::VT_SIZE_ORIGINAL, None)}
  }
  #[inline]
  pub fn filter(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(LibraryDataCellMap::VT_FILTER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn wrap(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(LibraryDataCellMap::VT_WRAP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn table_cell(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Cell<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Cell>>>>(LibraryDataCellMap::VT_TABLE_CELL, None)}
  }
}

impl flatbuffers::Verifiable for LibraryDataCellMap<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Vector2>>("size_original", Self::VT_SIZE_ORIGINAL, false)?
     .visit_field::<i16>("filter", Self::VT_FILTER, false)?
     .visit_field::<i16>("wrap", Self::VT_WRAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Cell>>>>("table_cell", Self::VT_TABLE_CELL, false)?
     .finish();
    Ok(())
  }
}
pub struct LibraryDataCellMapArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub size_original: Option<flatbuffers::WIPOffset<Vector2<'a>>>,
    pub filter: i16,
    pub wrap: i16,
    pub table_cell: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Cell<'a>>>>>,
}
impl<'a> Default for LibraryDataCellMapArgs<'a> {
  #[inline]
  fn default() -> Self {
    LibraryDataCellMapArgs {
      name: None,
      size_original: None,
      filter: 0,
      wrap: 0,
      table_cell: None,
    }
  }
}

pub struct LibraryDataCellMapBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LibraryDataCellMapBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LibraryDataCellMap::VT_NAME, name);
  }
  #[inline]
  pub fn add_size_original(&mut self, size_original: flatbuffers::WIPOffset<Vector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vector2>>(LibraryDataCellMap::VT_SIZE_ORIGINAL, size_original);
  }
  #[inline]
  pub fn add_filter(&mut self, filter: i16) {
    self.fbb_.push_slot::<i16>(LibraryDataCellMap::VT_FILTER, filter, 0);
  }
  #[inline]
  pub fn add_wrap(&mut self, wrap: i16) {
    self.fbb_.push_slot::<i16>(LibraryDataCellMap::VT_WRAP, wrap, 0);
  }
  #[inline]
  pub fn add_table_cell(&mut self, table_cell: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Cell<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LibraryDataCellMap::VT_TABLE_CELL, table_cell);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LibraryDataCellMapBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LibraryDataCellMapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LibraryDataCellMap<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LibraryDataCellMap<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LibraryDataCellMap");
      ds.field("name", &self.name());
      ds.field("size_original", &self.size_original());
      ds.field("filter", &self.filter());
      ds.field("wrap", &self.wrap());
      ds.field("table_cell", &self.table_cell());
      ds.finish()
  }
}
pub enum DataCellMapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataCellMap<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataCellMap<'a> {
  type Inner = DataCellMap<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataCellMap<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_INDEX_TEXTURE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLE_CELL_MAP: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataCellMap { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataCellMapArgs<'args>
  ) -> flatbuffers::WIPOffset<DataCellMap<'bldr>> {
    let mut builder = DataCellMapBuilder::new(_fbb);
    if let Some(x) = args.table_cell_map { builder.add_table_cell_map(x); }
    if let Some(x) = args.index_texture { builder.add_index_texture(x); }
    builder.add_version(args.version);
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DataCellMap::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn index_texture(&self) -> Option<flatbuffers::Vector<'a, i16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i16>>>(DataCellMap::VT_INDEX_TEXTURE, None)}
  }
  #[inline]
  pub fn table_cell_map(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LibraryDataCellMap<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LibraryDataCellMap>>>>(DataCellMap::VT_TABLE_CELL_MAP, None)}
  }
}

impl flatbuffers::Verifiable for DataCellMap<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i16>>>("index_texture", Self::VT_INDEX_TEXTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<LibraryDataCellMap>>>>("table_cell_map", Self::VT_TABLE_CELL_MAP, false)?
     .finish();
    Ok(())
  }
}
pub struct DataCellMapArgs<'a> {
    pub version: u32,
    pub index_texture: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i16>>>,
    pub table_cell_map: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LibraryDataCellMap<'a>>>>>,
}
impl<'a> Default for DataCellMapArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataCellMapArgs {
      version: 0,
      index_texture: None,
      table_cell_map: None,
    }
  }
}

pub struct DataCellMapBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataCellMapBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(DataCellMap::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_index_texture(&mut self, index_texture: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataCellMap::VT_INDEX_TEXTURE, index_texture);
  }
  #[inline]
  pub fn add_table_cell_map(&mut self, table_cell_map: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<LibraryDataCellMap<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataCellMap::VT_TABLE_CELL_MAP, table_cell_map);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataCellMapBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataCellMapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataCellMap<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataCellMap<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataCellMap");
      ds.field("version", &self.version());
      ds.field("index_texture", &self.index_texture());
      ds.field("table_cell_map", &self.table_cell_map());
      ds.finish()
  }
}
pub enum BoneOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Bone<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bone<'a> {
  type Inner = Bone<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Bone<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_COORDINATE_OFFSET: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Bone { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BoneArgs<'args>
  ) -> flatbuffers::WIPOffset<Bone<'bldr>> {
    let mut builder = BoneBuilder::new(_fbb);
    if let Some(x) = args.coordinate_offset { builder.add_coordinate_offset(x); }
    builder.add_weight(args.weight);
    builder.add_index(args.index);
    builder.finish()
  }


  #[inline]
  pub fn index(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Bone::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn weight(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Bone::VT_WEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn coordinate_offset(&self) -> Option<Vector3<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Vector3>>(Bone::VT_COORDINATE_OFFSET, None)}
  }
}

impl flatbuffers::Verifiable for Bone<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("index", Self::VT_INDEX, false)?
     .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Vector3>>("coordinate_offset", Self::VT_COORDINATE_OFFSET, false)?
     .finish();
    Ok(())
  }
}
pub struct BoneArgs<'a> {
    pub index: u16,
    pub weight: f32,
    pub coordinate_offset: Option<flatbuffers::WIPOffset<Vector3<'a>>>,
}
impl<'a> Default for BoneArgs<'a> {
  #[inline]
  fn default() -> Self {
    BoneArgs {
      index: 0,
      weight: 0.0,
      coordinate_offset: None,
    }
  }
}

pub struct BoneBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BoneBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_index(&mut self, index: u16) {
    self.fbb_.push_slot::<u16>(Bone::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_weight(&mut self, weight: f32) {
    self.fbb_.push_slot::<f32>(Bone::VT_WEIGHT, weight, 0.0);
  }
  #[inline]
  pub fn add_coordinate_offset(&mut self, coordinate_offset: flatbuffers::WIPOffset<Vector3<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vector3>>(Bone::VT_COORDINATE_OFFSET, coordinate_offset);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BoneBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BoneBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Bone<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Bone<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Bone");
      ds.field("index", &self.index());
      ds.field("weight", &self.weight());
      ds.field("coordinate_offset", &self.coordinate_offset());
      ds.finish()
  }
}
pub enum VertexOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Vertex<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Vertex<'a> {
  type Inner = Vertex<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Vertex<'a> {
  pub const VT_TABLE_BONE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Vertex { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args VertexArgs<'args>
  ) -> flatbuffers::WIPOffset<Vertex<'bldr>> {
    let mut builder = VertexBuilder::new(_fbb);
    if let Some(x) = args.table_bone { builder.add_table_bone(x); }
    builder.finish()
  }


  #[inline]
  pub fn table_bone(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bone<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bone>>>>(Vertex::VT_TABLE_BONE, None)}
  }
}

impl flatbuffers::Verifiable for Vertex<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Bone>>>>("table_bone", Self::VT_TABLE_BONE, false)?
     .finish();
    Ok(())
  }
}
pub struct VertexArgs<'a> {
    pub table_bone: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bone<'a>>>>>,
}
impl<'a> Default for VertexArgs<'a> {
  #[inline]
  fn default() -> Self {
    VertexArgs {
      table_bone: None,
    }
  }
}

pub struct VertexBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VertexBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_table_bone(&mut self, table_bone: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bone<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vertex::VT_TABLE_BONE, table_bone);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> VertexBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    VertexBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Vertex<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Vertex<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Vertex");
      ds.field("table_bone", &self.table_bone());
      ds.finish()
  }
}
pub enum BindMeshOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BindMesh<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BindMesh<'a> {
  type Inner = BindMesh<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BindMesh<'a> {
  pub const VT_COUNT_VERTEX: flatbuffers::VOffsetT = 4;
  pub const VT_TABLE_VERTEX: flatbuffers::VOffsetT = 6;
  pub const VT_TABLE_RATE_UV: flatbuffers::VOffsetT = 8;
  pub const VT_TABLE_INDEX_VERTEX: flatbuffers::VOffsetT = 10;
  pub const VT_COUNT_VERTEX_DEFORM: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BindMesh { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BindMeshArgs<'args>
  ) -> flatbuffers::WIPOffset<BindMesh<'bldr>> {
    let mut builder = BindMeshBuilder::new(_fbb);
    builder.add_count_vertex_deform(args.count_vertex_deform);
    if let Some(x) = args.table_index_vertex { builder.add_table_index_vertex(x); }
    if let Some(x) = args.table_rate_uv { builder.add_table_rate_uv(x); }
    if let Some(x) = args.table_vertex { builder.add_table_vertex(x); }
    builder.add_count_vertex(args.count_vertex);
    builder.finish()
  }


  #[inline]
  pub fn count_vertex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(BindMesh::VT_COUNT_VERTEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn table_vertex(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vertex<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vertex>>>>(BindMesh::VT_TABLE_VERTEX, None)}
  }
  #[inline]
  pub fn table_rate_uv(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2>>>>(BindMesh::VT_TABLE_RATE_UV, None)}
  }
  #[inline]
  pub fn table_index_vertex(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(BindMesh::VT_TABLE_INDEX_VERTEX, None)}
  }
  #[inline]
  pub fn count_vertex_deform(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(BindMesh::VT_COUNT_VERTEX_DEFORM, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BindMesh<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("count_vertex", Self::VT_COUNT_VERTEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Vertex>>>>("table_vertex", Self::VT_TABLE_VERTEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Vector2>>>>("table_rate_uv", Self::VT_TABLE_RATE_UV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_index_vertex", Self::VT_TABLE_INDEX_VERTEX, false)?
     .visit_field::<i32>("count_vertex_deform", Self::VT_COUNT_VERTEX_DEFORM, false)?
     .finish();
    Ok(())
  }
}
pub struct BindMeshArgs<'a> {
    pub count_vertex: i32,
    pub table_vertex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vertex<'a>>>>>,
    pub table_rate_uv: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2<'a>>>>>,
    pub table_index_vertex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub count_vertex_deform: i32,
}
impl<'a> Default for BindMeshArgs<'a> {
  #[inline]
  fn default() -> Self {
    BindMeshArgs {
      count_vertex: 0,
      table_vertex: None,
      table_rate_uv: None,
      table_index_vertex: None,
      count_vertex_deform: 0,
    }
  }
}

pub struct BindMeshBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BindMeshBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_count_vertex(&mut self, count_vertex: i32) {
    self.fbb_.push_slot::<i32>(BindMesh::VT_COUNT_VERTEX, count_vertex, 0);
  }
  #[inline]
  pub fn add_table_vertex(&mut self, table_vertex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Vertex<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BindMesh::VT_TABLE_VERTEX, table_vertex);
  }
  #[inline]
  pub fn add_table_rate_uv(&mut self, table_rate_uv: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Vector2<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BindMesh::VT_TABLE_RATE_UV, table_rate_uv);
  }
  #[inline]
  pub fn add_table_index_vertex(&mut self, table_index_vertex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BindMesh::VT_TABLE_INDEX_VERTEX, table_index_vertex);
  }
  #[inline]
  pub fn add_count_vertex_deform(&mut self, count_vertex_deform: i32) {
    self.fbb_.push_slot::<i32>(BindMesh::VT_COUNT_VERTEX_DEFORM, count_vertex_deform, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BindMeshBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BindMeshBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BindMesh<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BindMesh<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BindMesh");
      ds.field("count_vertex", &self.count_vertex());
      ds.field("table_vertex", &self.table_vertex());
      ds.field("table_rate_uv", &self.table_rate_uv());
      ds.field("table_index_vertex", &self.table_index_vertex());
      ds.field("count_vertex_deform", &self.count_vertex_deform());
      ds.finish()
  }
}
pub enum Color32Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Color32<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Color32<'a> {
  type Inner = Color32<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Color32<'a> {
  pub const VT_R: flatbuffers::VOffsetT = 4;
  pub const VT_G: flatbuffers::VOffsetT = 6;
  pub const VT_B: flatbuffers::VOffsetT = 8;
  pub const VT_A: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Color32 { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Color32Args
  ) -> flatbuffers::WIPOffset<Color32<'bldr>> {
    let mut builder = Color32Builder::new(_fbb);
    builder.add_a(args.a);
    builder.add_b(args.b);
    builder.add_g(args.g);
    builder.add_r(args.r);
    builder.finish()
  }


  #[inline]
  pub fn r(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Color32::VT_R, Some(0)).unwrap()}
  }
  #[inline]
  pub fn g(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Color32::VT_G, Some(0)).unwrap()}
  }
  #[inline]
  pub fn b(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Color32::VT_B, Some(0)).unwrap()}
  }
  #[inline]
  pub fn a(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Color32::VT_A, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Color32<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("r", Self::VT_R, false)?
     .visit_field::<u8>("g", Self::VT_G, false)?
     .visit_field::<u8>("b", Self::VT_B, false)?
     .visit_field::<u8>("a", Self::VT_A, false)?
     .finish();
    Ok(())
  }
}
pub struct Color32Args {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}
impl<'a> Default for Color32Args {
  #[inline]
  fn default() -> Self {
    Color32Args {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
    }
  }
}

pub struct Color32Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Color32Builder<'a, 'b, A> {
  #[inline]
  pub fn add_r(&mut self, r: u8) {
    self.fbb_.push_slot::<u8>(Color32::VT_R, r, 0);
  }
  #[inline]
  pub fn add_g(&mut self, g: u8) {
    self.fbb_.push_slot::<u8>(Color32::VT_G, g, 0);
  }
  #[inline]
  pub fn add_b(&mut self, b: u8) {
    self.fbb_.push_slot::<u8>(Color32::VT_B, b, 0);
  }
  #[inline]
  pub fn add_a(&mut self, a: u8) {
    self.fbb_.push_slot::<u8>(Color32::VT_A, a, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Color32Builder<'a, 'b, A> {
    let start = _fbb.start_table();
    Color32Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Color32<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Color32<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Color32");
      ds.field("r", &self.r());
      ds.field("g", &self.g());
      ds.field("b", &self.b());
      ds.field("a", &self.a());
      ds.finish()
  }
}
pub enum ColorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Color<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Color<'a> {
  type Inner = Color<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Color<'a> {
  pub const VT_R: flatbuffers::VOffsetT = 4;
  pub const VT_G: flatbuffers::VOffsetT = 6;
  pub const VT_B: flatbuffers::VOffsetT = 8;
  pub const VT_A: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Color { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ColorArgs
  ) -> flatbuffers::WIPOffset<Color<'bldr>> {
    let mut builder = ColorBuilder::new(_fbb);
    builder.add_a(args.a);
    builder.add_b(args.b);
    builder.add_g(args.g);
    builder.add_r(args.r);
    builder.finish()
  }


  #[inline]
  pub fn r(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Color::VT_R, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn g(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Color::VT_G, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn b(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Color::VT_B, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn a(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Color::VT_A, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Color<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("r", Self::VT_R, false)?
     .visit_field::<f32>("g", Self::VT_G, false)?
     .visit_field::<f32>("b", Self::VT_B, false)?
     .visit_field::<f32>("a", Self::VT_A, false)?
     .finish();
    Ok(())
  }
}
pub struct ColorArgs {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
impl<'a> Default for ColorArgs {
  #[inline]
  fn default() -> Self {
    ColorArgs {
      r: 0.0,
      g: 0.0,
      b: 0.0,
      a: 0.0,
    }
  }
}

pub struct ColorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ColorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_r(&mut self, r: f32) {
    self.fbb_.push_slot::<f32>(Color::VT_R, r, 0.0);
  }
  #[inline]
  pub fn add_g(&mut self, g: f32) {
    self.fbb_.push_slot::<f32>(Color::VT_G, g, 0.0);
  }
  #[inline]
  pub fn add_b(&mut self, b: f32) {
    self.fbb_.push_slot::<f32>(Color::VT_B, b, 0.0);
  }
  #[inline]
  pub fn add_a(&mut self, a: f32) {
    self.fbb_.push_slot::<f32>(Color::VT_A, a, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ColorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ColorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Color<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Color<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Color");
      ds.field("r", &self.r());
      ds.field("g", &self.g());
      ds.field("b", &self.b());
      ds.field("a", &self.a());
      ds.finish()
  }
}
pub enum ColorLabelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ColorLabel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ColorLabel<'a> {
  type Inner = ColorLabel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ColorLabel<'a> {
  pub const VT_FORM: flatbuffers::VOffsetT = 4;
  pub const VT_COLOR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ColorLabel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ColorLabelArgs<'args>
  ) -> flatbuffers::WIPOffset<ColorLabel<'bldr>> {
    let mut builder = ColorLabelBuilder::new(_fbb);
    if let Some(x) = args.color { builder.add_color(x); }
    builder.add_form(args.form);
    builder.finish()
  }


  #[inline]
  pub fn form(&self) -> ColorLabelKindForm {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ColorLabelKindForm>(ColorLabel::VT_FORM, Some(ColorLabelKindForm::Non)).unwrap()}
  }
  #[inline]
  pub fn color(&self) -> Option<Color32<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color32>>(ColorLabel::VT_COLOR, None)}
  }
}

impl flatbuffers::Verifiable for ColorLabel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ColorLabelKindForm>("form", Self::VT_FORM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color32>>("color", Self::VT_COLOR, false)?
     .finish();
    Ok(())
  }
}
pub struct ColorLabelArgs<'a> {
    pub form: ColorLabelKindForm,
    pub color: Option<flatbuffers::WIPOffset<Color32<'a>>>,
}
impl<'a> Default for ColorLabelArgs<'a> {
  #[inline]
  fn default() -> Self {
    ColorLabelArgs {
      form: ColorLabelKindForm::Non,
      color: None,
    }
  }
}

pub struct ColorLabelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ColorLabelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_form(&mut self, form: ColorLabelKindForm) {
    self.fbb_.push_slot::<ColorLabelKindForm>(ColorLabel::VT_FORM, form, ColorLabelKindForm::Non);
  }
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color32<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color32>>(ColorLabel::VT_COLOR, color);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ColorLabelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ColorLabelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ColorLabel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ColorLabel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ColorLabel");
      ds.field("form", &self.form());
      ds.field("color", &self.color());
      ds.finish()
  }
}
pub enum CatalogOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Catalog<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Catalog<'a> {
  type Inner = Catalog<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Catalog<'a> {
  pub const VT_TABLE_ID_PARTS_NULL: flatbuffers::VOffsetT = 4;
  pub const VT_TABLE_ID_PARTS_NORMAL: flatbuffers::VOffsetT = 6;
  pub const VT_TABLE_ID_PARTS_INSTANCE: flatbuffers::VOffsetT = 8;
  pub const VT_TABLE_ID_PARTS_EFFECT: flatbuffers::VOffsetT = 10;
  pub const VT_TABLE_ID_PARTS_MASK: flatbuffers::VOffsetT = 12;
  pub const VT_TABLE_ID_PARTS_JOINT: flatbuffers::VOffsetT = 14;
  pub const VT_TABLE_ID_PARTS_BONE: flatbuffers::VOffsetT = 16;
  pub const VT_TABLE_ID_PARTS_MOVE_NODE: flatbuffers::VOffsetT = 18;
  pub const VT_TABLE_ID_PARTS_CONSTRAINT: flatbuffers::VOffsetT = 20;
  pub const VT_TABLE_ID_PARTS_BONE_POINT: flatbuffers::VOffsetT = 22;
  pub const VT_TABLE_ID_PARTS_MESH: flatbuffers::VOffsetT = 24;
  pub const VT_TABLE_ID_PARTS_TRANSFORM_CONSTRAINT: flatbuffers::VOffsetT = 26;
  pub const VT_TABLE_ID_PARTS_CAMERA: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Catalog { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CatalogArgs<'args>
  ) -> flatbuffers::WIPOffset<Catalog<'bldr>> {
    let mut builder = CatalogBuilder::new(_fbb);
    if let Some(x) = args.table_id_parts_camera { builder.add_table_id_parts_camera(x); }
    if let Some(x) = args.table_id_parts_transform_constraint { builder.add_table_id_parts_transform_constraint(x); }
    if let Some(x) = args.table_id_parts_mesh { builder.add_table_id_parts_mesh(x); }
    if let Some(x) = args.table_id_parts_bone_point { builder.add_table_id_parts_bone_point(x); }
    if let Some(x) = args.table_id_parts_constraint { builder.add_table_id_parts_constraint(x); }
    if let Some(x) = args.table_id_parts_move_node { builder.add_table_id_parts_move_node(x); }
    if let Some(x) = args.table_id_parts_bone { builder.add_table_id_parts_bone(x); }
    if let Some(x) = args.table_id_parts_joint { builder.add_table_id_parts_joint(x); }
    if let Some(x) = args.table_id_parts_mask { builder.add_table_id_parts_mask(x); }
    if let Some(x) = args.table_id_parts_effect { builder.add_table_id_parts_effect(x); }
    if let Some(x) = args.table_id_parts_instance { builder.add_table_id_parts_instance(x); }
    if let Some(x) = args.table_id_parts_normal { builder.add_table_id_parts_normal(x); }
    if let Some(x) = args.table_id_parts_null { builder.add_table_id_parts_null(x); }
    builder.finish()
  }


  #[inline]
  pub fn table_id_parts_null(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Catalog::VT_TABLE_ID_PARTS_NULL, None)}
  }
  #[inline]
  pub fn table_id_parts_normal(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Catalog::VT_TABLE_ID_PARTS_NORMAL, None)}
  }
  #[inline]
  pub fn table_id_parts_instance(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Catalog::VT_TABLE_ID_PARTS_INSTANCE, None)}
  }
  #[inline]
  pub fn table_id_parts_effect(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Catalog::VT_TABLE_ID_PARTS_EFFECT, None)}
  }
  #[inline]
  pub fn table_id_parts_mask(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Catalog::VT_TABLE_ID_PARTS_MASK, None)}
  }
  #[inline]
  pub fn table_id_parts_joint(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Catalog::VT_TABLE_ID_PARTS_JOINT, None)}
  }
  #[inline]
  pub fn table_id_parts_bone(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Catalog::VT_TABLE_ID_PARTS_BONE, None)}
  }
  #[inline]
  pub fn table_id_parts_move_node(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Catalog::VT_TABLE_ID_PARTS_MOVE_NODE, None)}
  }
  #[inline]
  pub fn table_id_parts_constraint(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Catalog::VT_TABLE_ID_PARTS_CONSTRAINT, None)}
  }
  #[inline]
  pub fn table_id_parts_bone_point(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Catalog::VT_TABLE_ID_PARTS_BONE_POINT, None)}
  }
  #[inline]
  pub fn table_id_parts_mesh(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Catalog::VT_TABLE_ID_PARTS_MESH, None)}
  }
  #[inline]
  pub fn table_id_parts_transform_constraint(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Catalog::VT_TABLE_ID_PARTS_TRANSFORM_CONSTRAINT, None)}
  }
  #[inline]
  pub fn table_id_parts_camera(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Catalog::VT_TABLE_ID_PARTS_CAMERA, None)}
  }
}

impl flatbuffers::Verifiable for Catalog<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_id_parts_null", Self::VT_TABLE_ID_PARTS_NULL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_id_parts_normal", Self::VT_TABLE_ID_PARTS_NORMAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_id_parts_instance", Self::VT_TABLE_ID_PARTS_INSTANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_id_parts_effect", Self::VT_TABLE_ID_PARTS_EFFECT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_id_parts_mask", Self::VT_TABLE_ID_PARTS_MASK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_id_parts_joint", Self::VT_TABLE_ID_PARTS_JOINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_id_parts_bone", Self::VT_TABLE_ID_PARTS_BONE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_id_parts_move_node", Self::VT_TABLE_ID_PARTS_MOVE_NODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_id_parts_constraint", Self::VT_TABLE_ID_PARTS_CONSTRAINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_id_parts_bone_point", Self::VT_TABLE_ID_PARTS_BONE_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_id_parts_mesh", Self::VT_TABLE_ID_PARTS_MESH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_id_parts_transform_constraint", Self::VT_TABLE_ID_PARTS_TRANSFORM_CONSTRAINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("table_id_parts_camera", Self::VT_TABLE_ID_PARTS_CAMERA, false)?
     .finish();
    Ok(())
  }
}
pub struct CatalogArgs<'a> {
    pub table_id_parts_null: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub table_id_parts_normal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub table_id_parts_instance: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub table_id_parts_effect: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub table_id_parts_mask: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub table_id_parts_joint: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub table_id_parts_bone: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub table_id_parts_move_node: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub table_id_parts_constraint: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub table_id_parts_bone_point: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub table_id_parts_mesh: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub table_id_parts_transform_constraint: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub table_id_parts_camera: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for CatalogArgs<'a> {
  #[inline]
  fn default() -> Self {
    CatalogArgs {
      table_id_parts_null: None,
      table_id_parts_normal: None,
      table_id_parts_instance: None,
      table_id_parts_effect: None,
      table_id_parts_mask: None,
      table_id_parts_joint: None,
      table_id_parts_bone: None,
      table_id_parts_move_node: None,
      table_id_parts_constraint: None,
      table_id_parts_bone_point: None,
      table_id_parts_mesh: None,
      table_id_parts_transform_constraint: None,
      table_id_parts_camera: None,
    }
  }
}

pub struct CatalogBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CatalogBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_table_id_parts_null(&mut self, table_id_parts_null: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Catalog::VT_TABLE_ID_PARTS_NULL, table_id_parts_null);
  }
  #[inline]
  pub fn add_table_id_parts_normal(&mut self, table_id_parts_normal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Catalog::VT_TABLE_ID_PARTS_NORMAL, table_id_parts_normal);
  }
  #[inline]
  pub fn add_table_id_parts_instance(&mut self, table_id_parts_instance: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Catalog::VT_TABLE_ID_PARTS_INSTANCE, table_id_parts_instance);
  }
  #[inline]
  pub fn add_table_id_parts_effect(&mut self, table_id_parts_effect: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Catalog::VT_TABLE_ID_PARTS_EFFECT, table_id_parts_effect);
  }
  #[inline]
  pub fn add_table_id_parts_mask(&mut self, table_id_parts_mask: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Catalog::VT_TABLE_ID_PARTS_MASK, table_id_parts_mask);
  }
  #[inline]
  pub fn add_table_id_parts_joint(&mut self, table_id_parts_joint: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Catalog::VT_TABLE_ID_PARTS_JOINT, table_id_parts_joint);
  }
  #[inline]
  pub fn add_table_id_parts_bone(&mut self, table_id_parts_bone: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Catalog::VT_TABLE_ID_PARTS_BONE, table_id_parts_bone);
  }
  #[inline]
  pub fn add_table_id_parts_move_node(&mut self, table_id_parts_move_node: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Catalog::VT_TABLE_ID_PARTS_MOVE_NODE, table_id_parts_move_node);
  }
  #[inline]
  pub fn add_table_id_parts_constraint(&mut self, table_id_parts_constraint: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Catalog::VT_TABLE_ID_PARTS_CONSTRAINT, table_id_parts_constraint);
  }
  #[inline]
  pub fn add_table_id_parts_bone_point(&mut self, table_id_parts_bone_point: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Catalog::VT_TABLE_ID_PARTS_BONE_POINT, table_id_parts_bone_point);
  }
  #[inline]
  pub fn add_table_id_parts_mesh(&mut self, table_id_parts_mesh: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Catalog::VT_TABLE_ID_PARTS_MESH, table_id_parts_mesh);
  }
  #[inline]
  pub fn add_table_id_parts_transform_constraint(&mut self, table_id_parts_transform_constraint: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Catalog::VT_TABLE_ID_PARTS_TRANSFORM_CONSTRAINT, table_id_parts_transform_constraint);
  }
  #[inline]
  pub fn add_table_id_parts_camera(&mut self, table_id_parts_camera: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Catalog::VT_TABLE_ID_PARTS_CAMERA, table_id_parts_camera);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CatalogBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CatalogBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Catalog<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Catalog<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Catalog");
      ds.field("table_id_parts_null", &self.table_id_parts_null());
      ds.field("table_id_parts_normal", &self.table_id_parts_normal());
      ds.field("table_id_parts_instance", &self.table_id_parts_instance());
      ds.field("table_id_parts_effect", &self.table_id_parts_effect());
      ds.field("table_id_parts_mask", &self.table_id_parts_mask());
      ds.field("table_id_parts_joint", &self.table_id_parts_joint());
      ds.field("table_id_parts_bone", &self.table_id_parts_bone());
      ds.field("table_id_parts_move_node", &self.table_id_parts_move_node());
      ds.field("table_id_parts_constraint", &self.table_id_parts_constraint());
      ds.field("table_id_parts_bone_point", &self.table_id_parts_bone_point());
      ds.field("table_id_parts_mesh", &self.table_id_parts_mesh());
      ds.field("table_id_parts_transform_constraint", &self.table_id_parts_transform_constraint());
      ds.field("table_id_parts_camera", &self.table_id_parts_camera());
      ds.finish()
  }
}
pub enum DataModelPartsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataModelParts<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataModelParts<'a> {
  type Inner = DataModelParts<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataModelParts<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_ID_PARENT: flatbuffers::VOffsetT = 8;
  pub const VT_TABLE_ID_CHILDREN: flatbuffers::VOffsetT = 10;
  pub const VT_FEATURE: flatbuffers::VOffsetT = 12;
  pub const VT_COUNT_MESH: flatbuffers::VOffsetT = 14;
  pub const VT_MESH: flatbuffers::VOffsetT = 16;
  pub const VT_LABEL_COLOR: flatbuffers::VOffsetT = 18;
  pub const VT_OPERATION_BLEND_TARGET: flatbuffers::VOffsetT = 20;
  pub const VT_SHAPE_COLLISION: flatbuffers::VOffsetT = 22;
  pub const VT_SIZE_COLLISION: flatbuffers::VOffsetT = 24;
  pub const VT_INDEX_ANIMATION_PACK_UNDER_CONTROL: flatbuffers::VOffsetT = 26;
  pub const VT_INDEX_EFFECT_UNDER_CONTROL: flatbuffers::VOffsetT = 28;
  pub const VT_NAME_ANIMATION_UNDER_CONTROL: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataModelParts { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataModelPartsArgs<'args>
  ) -> flatbuffers::WIPOffset<DataModelParts<'bldr>> {
    let mut builder = DataModelPartsBuilder::new(_fbb);
    if let Some(x) = args.name_animation_under_control { builder.add_name_animation_under_control(x); }
    builder.add_size_collision(args.size_collision);
    if let Some(x) = args.label_color { builder.add_label_color(x); }
    if let Some(x) = args.mesh { builder.add_mesh(x); }
    builder.add_count_mesh(args.count_mesh);
    if let Some(x) = args.table_id_children { builder.add_table_id_children(x); }
    builder.add_id_parent(args.id_parent);
    builder.add_id(args.id);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_index_effect_under_control(args.index_effect_under_control);
    builder.add_index_animation_pack_under_control(args.index_animation_pack_under_control);
    builder.add_shape_collision(args.shape_collision);
    builder.add_operation_blend_target(args.operation_blend_target);
    builder.add_feature(args.feature);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataModelParts::VT_NAME, None)}
  }
  #[inline]
  pub fn id(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataModelParts::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn id_parent(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataModelParts::VT_ID_PARENT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn table_id_children(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(DataModelParts::VT_TABLE_ID_CHILDREN, None)}
  }
  #[inline]
  pub fn feature(&self) -> DataModelPartsKindFeature {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DataModelPartsKindFeature>(DataModelParts::VT_FEATURE, Some(DataModelPartsKindFeature::Root)).unwrap()}
  }
  #[inline]
  pub fn count_mesh(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataModelParts::VT_COUNT_MESH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn mesh(&self) -> Option<BindMesh<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BindMesh>>(DataModelParts::VT_MESH, None)}
  }
  #[inline]
  pub fn label_color(&self) -> Option<ColorLabel<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ColorLabel>>(DataModelParts::VT_LABEL_COLOR, None)}
  }
  #[inline]
  pub fn operation_blend_target(&self) -> KindOperationBlend {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindOperationBlend>(DataModelParts::VT_OPERATION_BLEND_TARGET, Some(KindOperationBlend::Mix)).unwrap()}
  }
  #[inline]
  pub fn shape_collision(&self) -> KindCollision {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindCollision>(DataModelParts::VT_SHAPE_COLLISION, Some(KindCollision::Non)).unwrap()}
  }
  #[inline]
  pub fn size_collision(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DataModelParts::VT_SIZE_COLLISION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn index_animation_pack_under_control(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DataModelParts::VT_INDEX_ANIMATION_PACK_UNDER_CONTROL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn index_effect_under_control(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DataModelParts::VT_INDEX_EFFECT_UNDER_CONTROL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name_animation_under_control(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataModelParts::VT_NAME_ANIMATION_UNDER_CONTROL, None)}
  }
}

impl flatbuffers::Verifiable for DataModelParts<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<i32>("id", Self::VT_ID, false)?
     .visit_field::<i32>("id_parent", Self::VT_ID_PARENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("table_id_children", Self::VT_TABLE_ID_CHILDREN, false)?
     .visit_field::<DataModelPartsKindFeature>("feature", Self::VT_FEATURE, false)?
     .visit_field::<i32>("count_mesh", Self::VT_COUNT_MESH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BindMesh>>("mesh", Self::VT_MESH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ColorLabel>>("label_color", Self::VT_LABEL_COLOR, false)?
     .visit_field::<KindOperationBlend>("operation_blend_target", Self::VT_OPERATION_BLEND_TARGET, false)?
     .visit_field::<KindCollision>("shape_collision", Self::VT_SHAPE_COLLISION, false)?
     .visit_field::<f32>("size_collision", Self::VT_SIZE_COLLISION, false)?
     .visit_field::<u16>("index_animation_pack_under_control", Self::VT_INDEX_ANIMATION_PACK_UNDER_CONTROL, false)?
     .visit_field::<u16>("index_effect_under_control", Self::VT_INDEX_EFFECT_UNDER_CONTROL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name_animation_under_control", Self::VT_NAME_ANIMATION_UNDER_CONTROL, false)?
     .finish();
    Ok(())
  }
}
pub struct DataModelPartsArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: i32,
    pub id_parent: i32,
    pub table_id_children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub feature: DataModelPartsKindFeature,
    pub count_mesh: i32,
    pub mesh: Option<flatbuffers::WIPOffset<BindMesh<'a>>>,
    pub label_color: Option<flatbuffers::WIPOffset<ColorLabel<'a>>>,
    pub operation_blend_target: KindOperationBlend,
    pub shape_collision: KindCollision,
    pub size_collision: f32,
    pub index_animation_pack_under_control: u16,
    pub index_effect_under_control: u16,
    pub name_animation_under_control: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DataModelPartsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataModelPartsArgs {
      name: None,
      id: 0,
      id_parent: 0,
      table_id_children: None,
      feature: DataModelPartsKindFeature::Root,
      count_mesh: 0,
      mesh: None,
      label_color: None,
      operation_blend_target: KindOperationBlend::Mix,
      shape_collision: KindCollision::Non,
      size_collision: 0.0,
      index_animation_pack_under_control: 0,
      index_effect_under_control: 0,
      name_animation_under_control: None,
    }
  }
}

pub struct DataModelPartsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataModelPartsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataModelParts::VT_NAME, name);
  }
  #[inline]
  pub fn add_id(&mut self, id: i32) {
    self.fbb_.push_slot::<i32>(DataModelParts::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_id_parent(&mut self, id_parent: i32) {
    self.fbb_.push_slot::<i32>(DataModelParts::VT_ID_PARENT, id_parent, 0);
  }
  #[inline]
  pub fn add_table_id_children(&mut self, table_id_children: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataModelParts::VT_TABLE_ID_CHILDREN, table_id_children);
  }
  #[inline]
  pub fn add_feature(&mut self, feature: DataModelPartsKindFeature) {
    self.fbb_.push_slot::<DataModelPartsKindFeature>(DataModelParts::VT_FEATURE, feature, DataModelPartsKindFeature::Root);
  }
  #[inline]
  pub fn add_count_mesh(&mut self, count_mesh: i32) {
    self.fbb_.push_slot::<i32>(DataModelParts::VT_COUNT_MESH, count_mesh, 0);
  }
  #[inline]
  pub fn add_mesh(&mut self, mesh: flatbuffers::WIPOffset<BindMesh<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BindMesh>>(DataModelParts::VT_MESH, mesh);
  }
  #[inline]
  pub fn add_label_color(&mut self, label_color: flatbuffers::WIPOffset<ColorLabel<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ColorLabel>>(DataModelParts::VT_LABEL_COLOR, label_color);
  }
  #[inline]
  pub fn add_operation_blend_target(&mut self, operation_blend_target: KindOperationBlend) {
    self.fbb_.push_slot::<KindOperationBlend>(DataModelParts::VT_OPERATION_BLEND_TARGET, operation_blend_target, KindOperationBlend::Mix);
  }
  #[inline]
  pub fn add_shape_collision(&mut self, shape_collision: KindCollision) {
    self.fbb_.push_slot::<KindCollision>(DataModelParts::VT_SHAPE_COLLISION, shape_collision, KindCollision::Non);
  }
  #[inline]
  pub fn add_size_collision(&mut self, size_collision: f32) {
    self.fbb_.push_slot::<f32>(DataModelParts::VT_SIZE_COLLISION, size_collision, 0.0);
  }
  #[inline]
  pub fn add_index_animation_pack_under_control(&mut self, index_animation_pack_under_control: u16) {
    self.fbb_.push_slot::<u16>(DataModelParts::VT_INDEX_ANIMATION_PACK_UNDER_CONTROL, index_animation_pack_under_control, 0);
  }
  #[inline]
  pub fn add_index_effect_under_control(&mut self, index_effect_under_control: u16) {
    self.fbb_.push_slot::<u16>(DataModelParts::VT_INDEX_EFFECT_UNDER_CONTROL, index_effect_under_control, 0);
  }
  #[inline]
  pub fn add_name_animation_under_control(&mut self, name_animation_under_control: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataModelParts::VT_NAME_ANIMATION_UNDER_CONTROL, name_animation_under_control);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataModelPartsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataModelPartsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataModelParts<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataModelParts<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataModelParts");
      ds.field("name", &self.name());
      ds.field("id", &self.id());
      ds.field("id_parent", &self.id_parent());
      ds.field("table_id_children", &self.table_id_children());
      ds.field("feature", &self.feature());
      ds.field("count_mesh", &self.count_mesh());
      ds.field("mesh", &self.mesh());
      ds.field("label_color", &self.label_color());
      ds.field("operation_blend_target", &self.operation_blend_target());
      ds.field("shape_collision", &self.shape_collision());
      ds.field("size_collision", &self.size_collision());
      ds.field("index_animation_pack_under_control", &self.index_animation_pack_under_control());
      ds.field("index_effect_under_control", &self.index_effect_under_control());
      ds.field("name_animation_under_control", &self.name_animation_under_control());
      ds.finish()
  }
}
pub enum LabelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Label<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Label<'a> {
  type Inner = Label<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Label<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_FRAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Label { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LabelArgs<'args>
  ) -> flatbuffers::WIPOffset<Label<'bldr>> {
    let mut builder = LabelBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_frame(args.frame);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Label::VT_NAME, None)}
  }
  #[inline]
  pub fn frame(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Label::VT_FRAME, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Label<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u16>("frame", Self::VT_FRAME, false)?
     .finish();
    Ok(())
  }
}
pub struct LabelArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub frame: u16,
}
impl<'a> Default for LabelArgs<'a> {
  #[inline]
  fn default() -> Self {
    LabelArgs {
      name: None,
      frame: 0,
    }
  }
}

pub struct LabelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LabelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Label::VT_NAME, name);
  }
  #[inline]
  pub fn add_frame(&mut self, frame: u16) {
    self.fbb_.push_slot::<u16>(Label::VT_FRAME, frame, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LabelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LabelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Label<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Label<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Label");
      ds.field("name", &self.name());
      ds.field("frame", &self.frame());
      ds.finish()
  }
}
pub enum RangeFloatOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RangeFloat<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RangeFloat<'a> {
  type Inner = RangeFloat<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RangeFloat<'a> {
  pub const VT_MAIN: flatbuffers::VOffsetT = 4;
  pub const VT_SUB: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RangeFloat { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RangeFloatArgs
  ) -> flatbuffers::WIPOffset<RangeFloat<'bldr>> {
    let mut builder = RangeFloatBuilder::new(_fbb);
    builder.add_sub(args.sub);
    builder.add_main(args.main);
    builder.finish()
  }


  #[inline]
  pub fn main(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(RangeFloat::VT_MAIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn sub(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(RangeFloat::VT_SUB, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RangeFloat<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("main", Self::VT_MAIN, false)?
     .visit_field::<f32>("sub", Self::VT_SUB, false)?
     .finish();
    Ok(())
  }
}
pub struct RangeFloatArgs {
    pub main: f32,
    pub sub: f32,
}
impl<'a> Default for RangeFloatArgs {
  #[inline]
  fn default() -> Self {
    RangeFloatArgs {
      main: 0.0,
      sub: 0.0,
    }
  }
}

pub struct RangeFloatBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RangeFloatBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_main(&mut self, main: f32) {
    self.fbb_.push_slot::<f32>(RangeFloat::VT_MAIN, main, 0.0);
  }
  #[inline]
  pub fn add_sub(&mut self, sub: f32) {
    self.fbb_.push_slot::<f32>(RangeFloat::VT_SUB, sub, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RangeFloatBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RangeFloatBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RangeFloat<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RangeFloat<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RangeFloat");
      ds.field("main", &self.main());
      ds.field("sub", &self.sub());
      ds.finish()
  }
}
pub enum RangeVector2Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RangeVector2<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RangeVector2<'a> {
  type Inner = RangeVector2<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RangeVector2<'a> {
  pub const VT_MAIN: flatbuffers::VOffsetT = 4;
  pub const VT_SUB: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RangeVector2 { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RangeVector2Args<'args>
  ) -> flatbuffers::WIPOffset<RangeVector2<'bldr>> {
    let mut builder = RangeVector2Builder::new(_fbb);
    if let Some(x) = args.sub { builder.add_sub(x); }
    if let Some(x) = args.main { builder.add_main(x); }
    builder.finish()
  }


  #[inline]
  pub fn main(&self) -> Option<Vector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Vector2>>(RangeVector2::VT_MAIN, None)}
  }
  #[inline]
  pub fn sub(&self) -> Option<Vector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Vector2>>(RangeVector2::VT_SUB, None)}
  }
}

impl flatbuffers::Verifiable for RangeVector2<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Vector2>>("main", Self::VT_MAIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Vector2>>("sub", Self::VT_SUB, false)?
     .finish();
    Ok(())
  }
}
pub struct RangeVector2Args<'a> {
    pub main: Option<flatbuffers::WIPOffset<Vector2<'a>>>,
    pub sub: Option<flatbuffers::WIPOffset<Vector2<'a>>>,
}
impl<'a> Default for RangeVector2Args<'a> {
  #[inline]
  fn default() -> Self {
    RangeVector2Args {
      main: None,
      sub: None,
    }
  }
}

pub struct RangeVector2Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RangeVector2Builder<'a, 'b, A> {
  #[inline]
  pub fn add_main(&mut self, main: flatbuffers::WIPOffset<Vector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vector2>>(RangeVector2::VT_MAIN, main);
  }
  #[inline]
  pub fn add_sub(&mut self, sub: flatbuffers::WIPOffset<Vector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vector2>>(RangeVector2::VT_SUB, sub);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RangeVector2Builder<'a, 'b, A> {
    let start = _fbb.start_table();
    RangeVector2Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RangeVector2<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RangeVector2<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RangeVector2");
      ds.field("main", &self.main());
      ds.field("sub", &self.sub());
      ds.finish()
  }
}
pub enum RangeColorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RangeColor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RangeColor<'a> {
  type Inner = RangeColor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RangeColor<'a> {
  pub const VT_MAIN: flatbuffers::VOffsetT = 4;
  pub const VT_SUB: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RangeColor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RangeColorArgs<'args>
  ) -> flatbuffers::WIPOffset<RangeColor<'bldr>> {
    let mut builder = RangeColorBuilder::new(_fbb);
    if let Some(x) = args.sub { builder.add_sub(x); }
    if let Some(x) = args.main { builder.add_main(x); }
    builder.finish()
  }


  #[inline]
  pub fn main(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(RangeColor::VT_MAIN, None)}
  }
  #[inline]
  pub fn sub(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(RangeColor::VT_SUB, None)}
  }
}

impl flatbuffers::Verifiable for RangeColor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("main", Self::VT_MAIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("sub", Self::VT_SUB, false)?
     .finish();
    Ok(())
  }
}
pub struct RangeColorArgs<'a> {
    pub main: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub sub: Option<flatbuffers::WIPOffset<Color<'a>>>,
}
impl<'a> Default for RangeColorArgs<'a> {
  #[inline]
  fn default() -> Self {
    RangeColorArgs {
      main: None,
      sub: None,
    }
  }
}

pub struct RangeColorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RangeColorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_main(&mut self, main: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(RangeColor::VT_MAIN, main);
  }
  #[inline]
  pub fn add_sub(&mut self, sub: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(RangeColor::VT_SUB, sub);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RangeColorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RangeColorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RangeColor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RangeColor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RangeColor");
      ds.field("main", &self.main());
      ds.field("sub", &self.sub());
      ds.finish()
  }
}
pub enum PatternEmitOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PatternEmit<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PatternEmit<'a> {
  type Inner = PatternEmit<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PatternEmit<'a> {
  pub const VT_INDEX_GENERATE: flatbuffers::VOffsetT = 4;
  pub const VT_DURATION: flatbuffers::VOffsetT = 6;
  pub const VT_CYCLE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PatternEmit { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PatternEmitArgs
  ) -> flatbuffers::WIPOffset<PatternEmit<'bldr>> {
    let mut builder = PatternEmitBuilder::new(_fbb);
    builder.add_cycle(args.cycle);
    builder.add_duration(args.duration);
    builder.add_index_generate(args.index_generate);
    builder.finish()
  }


  #[inline]
  pub fn index_generate(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PatternEmit::VT_INDEX_GENERATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn duration(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PatternEmit::VT_DURATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn cycle(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PatternEmit::VT_CYCLE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PatternEmit<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("index_generate", Self::VT_INDEX_GENERATE, false)?
     .visit_field::<i32>("duration", Self::VT_DURATION, false)?
     .visit_field::<i32>("cycle", Self::VT_CYCLE, false)?
     .finish();
    Ok(())
  }
}
pub struct PatternEmitArgs {
    pub index_generate: i32,
    pub duration: i32,
    pub cycle: i32,
}
impl<'a> Default for PatternEmitArgs {
  #[inline]
  fn default() -> Self {
    PatternEmitArgs {
      index_generate: 0,
      duration: 0,
      cycle: 0,
    }
  }
}

pub struct PatternEmitBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PatternEmitBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_index_generate(&mut self, index_generate: i32) {
    self.fbb_.push_slot::<i32>(PatternEmit::VT_INDEX_GENERATE, index_generate, 0);
  }
  #[inline]
  pub fn add_duration(&mut self, duration: i32) {
    self.fbb_.push_slot::<i32>(PatternEmit::VT_DURATION, duration, 0);
  }
  #[inline]
  pub fn add_cycle(&mut self, cycle: i32) {
    self.fbb_.push_slot::<i32>(PatternEmit::VT_CYCLE, cycle, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PatternEmitBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PatternEmitBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PatternEmit<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PatternEmit<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PatternEmit");
      ds.field("index_generate", &self.index_generate());
      ds.field("duration", &self.duration());
      ds.field("cycle", &self.cycle());
      ds.finish()
  }
}
pub enum AnimationAttributeCellOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnimationAttributeCell<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnimationAttributeCell<'a> {
  type Inner = AnimationAttributeCell<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AnimationAttributeCell<'a> {
  pub const VT_INDEXCELLMAP: flatbuffers::VOffsetT = 4;
  pub const VT_INDEXCELL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AnimationAttributeCell { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AnimationAttributeCellArgs
  ) -> flatbuffers::WIPOffset<AnimationAttributeCell<'bldr>> {
    let mut builder = AnimationAttributeCellBuilder::new(_fbb);
    builder.add_IndexCell(args.IndexCell);
    builder.add_IndexCellMap(args.IndexCellMap);
    builder.finish()
  }


  #[inline]
  pub fn IndexCellMap(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AnimationAttributeCell::VT_INDEXCELLMAP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IndexCell(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AnimationAttributeCell::VT_INDEXCELL, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AnimationAttributeCell<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("IndexCellMap", Self::VT_INDEXCELLMAP, false)?
     .visit_field::<i32>("IndexCell", Self::VT_INDEXCELL, false)?
     .finish();
    Ok(())
  }
}
pub struct AnimationAttributeCellArgs {
    pub IndexCellMap: i32,
    pub IndexCell: i32,
}
impl<'a> Default for AnimationAttributeCellArgs {
  #[inline]
  fn default() -> Self {
    AnimationAttributeCellArgs {
      IndexCellMap: 0,
      IndexCell: 0,
    }
  }
}

pub struct AnimationAttributeCellBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimationAttributeCellBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_IndexCellMap(&mut self, IndexCellMap: i32) {
    self.fbb_.push_slot::<i32>(AnimationAttributeCell::VT_INDEXCELLMAP, IndexCellMap, 0);
  }
  #[inline]
  pub fn add_IndexCell(&mut self, IndexCell: i32) {
    self.fbb_.push_slot::<i32>(AnimationAttributeCell::VT_INDEXCELL, IndexCell, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AnimationAttributeCellBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AnimationAttributeCellBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AnimationAttributeCell<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AnimationAttributeCell<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AnimationAttributeCell");
      ds.field("IndexCellMap", &self.IndexCellMap());
      ds.field("IndexCell", &self.IndexCell());
      ds.finish()
  }
}
pub enum AnimationAttributePartsColorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnimationAttributePartsColor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnimationAttributePartsColor<'a> {
  type Inner = AnimationAttributePartsColor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AnimationAttributePartsColor<'a> {
  pub const VT_BOUND: flatbuffers::VOffsetT = 4;
  pub const VT_OPERATION: flatbuffers::VOffsetT = 6;
  pub const VT_VERTEXCOLOR: flatbuffers::VOffsetT = 8;
  pub const VT_RATEALPHA: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AnimationAttributePartsColor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AnimationAttributePartsColorArgs<'args>
  ) -> flatbuffers::WIPOffset<AnimationAttributePartsColor<'bldr>> {
    let mut builder = AnimationAttributePartsColorBuilder::new(_fbb);
    if let Some(x) = args.RateAlpha { builder.add_RateAlpha(x); }
    if let Some(x) = args.VertexColor { builder.add_VertexColor(x); }
    builder.add_Operation(args.Operation);
    builder.add_Bound(args.Bound);
    builder.finish()
  }


  #[inline]
  pub fn Bound(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(AnimationAttributePartsColor::VT_BOUND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Operation(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(AnimationAttributePartsColor::VT_OPERATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn VertexColor(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Color<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Color>>>>(AnimationAttributePartsColor::VT_VERTEXCOLOR, None)}
  }
  #[inline]
  pub fn RateAlpha(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(AnimationAttributePartsColor::VT_RATEALPHA, None)}
  }
}

impl flatbuffers::Verifiable for AnimationAttributePartsColor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i16>("Bound", Self::VT_BOUND, false)?
     .visit_field::<i16>("Operation", Self::VT_OPERATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Color>>>>("VertexColor", Self::VT_VERTEXCOLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("RateAlpha", Self::VT_RATEALPHA, false)?
     .finish();
    Ok(())
  }
}
pub struct AnimationAttributePartsColorArgs<'a> {
    pub Bound: i16,
    pub Operation: i16,
    pub VertexColor: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Color<'a>>>>>,
    pub RateAlpha: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for AnimationAttributePartsColorArgs<'a> {
  #[inline]
  fn default() -> Self {
    AnimationAttributePartsColorArgs {
      Bound: 0,
      Operation: 0,
      VertexColor: None,
      RateAlpha: None,
    }
  }
}

pub struct AnimationAttributePartsColorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimationAttributePartsColorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Bound(&mut self, Bound: i16) {
    self.fbb_.push_slot::<i16>(AnimationAttributePartsColor::VT_BOUND, Bound, 0);
  }
  #[inline]
  pub fn add_Operation(&mut self, Operation: i16) {
    self.fbb_.push_slot::<i16>(AnimationAttributePartsColor::VT_OPERATION, Operation, 0);
  }
  #[inline]
  pub fn add_VertexColor(&mut self, VertexColor: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Color<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AnimationAttributePartsColor::VT_VERTEXCOLOR, VertexColor);
  }
  #[inline]
  pub fn add_RateAlpha(&mut self, RateAlpha: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AnimationAttributePartsColor::VT_RATEALPHA, RateAlpha);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AnimationAttributePartsColorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AnimationAttributePartsColorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AnimationAttributePartsColor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AnimationAttributePartsColor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AnimationAttributePartsColor");
      ds.field("Bound", &self.Bound());
      ds.field("Operation", &self.Operation());
      ds.field("VertexColor", &self.VertexColor());
      ds.field("RateAlpha", &self.RateAlpha());
      ds.finish()
  }
}
pub enum CodeValueContainerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CodeValueContainer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CodeValueContainer<'a> {
  type Inner = CodeValueContainer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CodeValueContainer<'a> {
  pub const VT_TABLECODE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CodeValueContainer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CodeValueContainerArgs<'args>
  ) -> flatbuffers::WIPOffset<CodeValueContainer<'bldr>> {
    let mut builder = CodeValueContainerBuilder::new(_fbb);
    if let Some(x) = args.TableCode { builder.add_TableCode(x); }
    builder.finish()
  }


  #[inline]
  pub fn TableCode(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(CodeValueContainer::VT_TABLECODE, None)}
  }
}

impl flatbuffers::Verifiable for CodeValueContainer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("TableCode", Self::VT_TABLECODE, false)?
     .finish();
    Ok(())
  }
}
pub struct CodeValueContainerArgs<'a> {
    pub TableCode: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for CodeValueContainerArgs<'a> {
  #[inline]
  fn default() -> Self {
    CodeValueContainerArgs {
      TableCode: None,
    }
  }
}

pub struct CodeValueContainerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CodeValueContainerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TableCode(&mut self, TableCode: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CodeValueContainer::VT_TABLECODE, TableCode);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CodeValueContainerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CodeValueContainerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CodeValueContainer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CodeValueContainer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CodeValueContainer");
      ds.field("TableCode", &self.TableCode());
      ds.finish()
  }
}
pub enum ContainerStatusOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerStatus<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerStatus<'a> {
  type Inner = ContainerStatus<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerStatus<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerStatus { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerStatusArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerStatus<'bldr>> {
    let mut builder = ContainerStatusBuilder::new(_fbb);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerStatus::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerStatus::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(ContainerStatus::VT_TABLEVALUE, None)}
  }
}

impl flatbuffers::Verifiable for ContainerStatus<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerStatusArgs<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for ContainerStatusArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerStatusArgs {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
    }
  }
}

pub struct ContainerStatusBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerStatusBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerStatus::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerStatus::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerStatus::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerStatusBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerStatusBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerStatus<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerStatus<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerStatus");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.finish()
  }
}
pub enum ContainerCellOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerCell<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerCell<'a> {
  type Inner = ContainerCell<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerCell<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerCell { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerCellArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerCell<'bldr>> {
    let mut builder = ContainerCellBuilder::new(_fbb);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerCell::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerCell::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeCell<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeCell>>>>(ContainerCell::VT_TABLEVALUE, None)}
  }
}

impl flatbuffers::Verifiable for ContainerCell<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnimationAttributeCell>>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerCellArgs<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeCell<'a>>>>>,
}
impl<'a> Default for ContainerCellArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerCellArgs {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
    }
  }
}

pub struct ContainerCellBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerCellBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerCell::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerCell::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AnimationAttributeCell<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerCell::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerCellBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerCellBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerCell<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerCell<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerCell");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.finish()
  }
}
pub enum ContainerVector3Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerVector3<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerVector3<'a> {
  type Inner = ContainerVector3<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerVector3<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerVector3 { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerVector3Args<'args>
  ) -> flatbuffers::WIPOffset<ContainerVector3<'bldr>> {
    let mut builder = ContainerVector3Builder::new(_fbb);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerVector3::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerVector3::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector3<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector3>>>>(ContainerVector3::VT_TABLEVALUE, None)}
  }
}

impl flatbuffers::Verifiable for ContainerVector3<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Vector3>>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerVector3Args<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector3<'a>>>>>,
}
impl<'a> Default for ContainerVector3Args<'a> {
  #[inline]
  fn default() -> Self {
    ContainerVector3Args {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
    }
  }
}

pub struct ContainerVector3Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerVector3Builder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerVector3::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerVector3::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Vector3<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerVector3::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerVector3Builder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerVector3Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerVector3<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerVector3<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerVector3");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.finish()
  }
}
pub enum ContainerVector2Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerVector2<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerVector2<'a> {
  type Inner = ContainerVector2<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerVector2<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerVector2 { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerVector2Args<'args>
  ) -> flatbuffers::WIPOffset<ContainerVector2<'bldr>> {
    let mut builder = ContainerVector2Builder::new(_fbb);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerVector2::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerVector2::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2>>>>(ContainerVector2::VT_TABLEVALUE, None)}
  }
}

impl flatbuffers::Verifiable for ContainerVector2<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Vector2>>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerVector2Args<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2<'a>>>>>,
}
impl<'a> Default for ContainerVector2Args<'a> {
  #[inline]
  fn default() -> Self {
    ContainerVector2Args {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
    }
  }
}

pub struct ContainerVector2Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerVector2Builder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerVector2::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerVector2::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Vector2<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerVector2::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerVector2Builder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerVector2Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerVector2<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerVector2<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerVector2");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.finish()
  }
}
pub enum ContainerFloatOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerFloat<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerFloat<'a> {
  type Inner = ContainerFloat<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerFloat<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerFloat { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerFloatArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerFloat<'bldr>> {
    let mut builder = ContainerFloatBuilder::new(_fbb);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerFloat::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerFloat::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(ContainerFloat::VT_TABLEVALUE, None)}
  }
}

impl flatbuffers::Verifiable for ContainerFloat<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerFloatArgs<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for ContainerFloatArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerFloatArgs {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
    }
  }
}

pub struct ContainerFloatBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerFloatBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerFloat::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerFloat::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerFloat::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerFloatBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerFloatBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerFloat<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerFloat<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerFloat");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.finish()
  }
}
pub enum ContainerIntOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerInt<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerInt<'a> {
  type Inner = ContainerInt<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerInt<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerInt { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerIntArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerInt<'bldr>> {
    let mut builder = ContainerIntBuilder::new(_fbb);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerInt::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerInt::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(ContainerInt::VT_TABLEVALUE, None)}
  }
}

impl flatbuffers::Verifiable for ContainerInt<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerIntArgs<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for ContainerIntArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerIntArgs {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
    }
  }
}

pub struct ContainerIntBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerIntBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerInt::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerInt::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerInt::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerIntBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerIntBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerInt<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerInt<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerInt");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.finish()
  }
}
pub enum ContainerPartsColorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerPartsColor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerPartsColor<'a> {
  type Inner = ContainerPartsColor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerPartsColor<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerPartsColor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerPartsColorArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerPartsColor<'bldr>> {
    let mut builder = ContainerPartsColorBuilder::new(_fbb);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerPartsColor::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerPartsColor::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributePartsColor<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributePartsColor>>>>(ContainerPartsColor::VT_TABLEVALUE, None)}
  }
}

impl flatbuffers::Verifiable for ContainerPartsColor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnimationAttributePartsColor>>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerPartsColorArgs<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributePartsColor<'a>>>>>,
}
impl<'a> Default for ContainerPartsColorArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerPartsColorArgs {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
    }
  }
}

pub struct ContainerPartsColorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerPartsColorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerPartsColor::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerPartsColor::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AnimationAttributePartsColor<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerPartsColor::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerPartsColorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerPartsColorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerPartsColor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerPartsColor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerPartsColor");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.finish()
  }
}
pub enum VertexCorrectionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VertexCorrection<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VertexCorrection<'a> {
  type Inner = VertexCorrection<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VertexCorrection<'a> {
  pub const VT_COORDINATE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VertexCorrection { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args VertexCorrectionArgs<'args>
  ) -> flatbuffers::WIPOffset<VertexCorrection<'bldr>> {
    let mut builder = VertexCorrectionBuilder::new(_fbb);
    if let Some(x) = args.Coordinate { builder.add_Coordinate(x); }
    builder.finish()
  }


  #[inline]
  pub fn Coordinate(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2>>>>(VertexCorrection::VT_COORDINATE, None)}
  }
}

impl flatbuffers::Verifiable for VertexCorrection<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Vector2>>>>("Coordinate", Self::VT_COORDINATE, false)?
     .finish();
    Ok(())
  }
}
pub struct VertexCorrectionArgs<'a> {
    pub Coordinate: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2<'a>>>>>,
}
impl<'a> Default for VertexCorrectionArgs<'a> {
  #[inline]
  fn default() -> Self {
    VertexCorrectionArgs {
      Coordinate: None,
    }
  }
}

pub struct VertexCorrectionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VertexCorrectionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Coordinate(&mut self, Coordinate: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Vector2<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VertexCorrection::VT_COORDINATE, Coordinate);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> VertexCorrectionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    VertexCorrectionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VertexCorrection<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VertexCorrection<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VertexCorrection");
      ds.field("Coordinate", &self.Coordinate());
      ds.finish()
  }
}
pub enum ContainerVertexCorrectionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerVertexCorrection<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerVertexCorrection<'a> {
  type Inner = ContainerVertexCorrection<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerVertexCorrection<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerVertexCorrection { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerVertexCorrectionArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerVertexCorrection<'bldr>> {
    let mut builder = ContainerVertexCorrectionBuilder::new(_fbb);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerVertexCorrection::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerVertexCorrection::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VertexCorrection<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VertexCorrection>>>>(ContainerVertexCorrection::VT_TABLEVALUE, None)}
  }
}

impl flatbuffers::Verifiable for ContainerVertexCorrection<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<VertexCorrection>>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerVertexCorrectionArgs<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VertexCorrection<'a>>>>>,
}
impl<'a> Default for ContainerVertexCorrectionArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerVertexCorrectionArgs {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
    }
  }
}

pub struct ContainerVertexCorrectionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerVertexCorrectionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerVertexCorrection::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerVertexCorrection::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<VertexCorrection<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerVertexCorrection::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerVertexCorrectionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerVertexCorrectionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerVertexCorrection<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerVertexCorrection<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerVertexCorrection");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.finish()
  }
}
pub enum ContainerUserDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerUserData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerUserData<'a> {
  type Inner = ContainerUserData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerUserData<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerUserData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerUserDataArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerUserData<'bldr>> {
    let mut builder = ContainerUserDataBuilder::new(_fbb);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerUserData::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerUserData::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UserData<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UserData>>>>(ContainerUserData::VT_TABLEVALUE, None)}
  }
}

impl flatbuffers::Verifiable for ContainerUserData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<UserData>>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerUserDataArgs<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UserData<'a>>>>>,
}
impl<'a> Default for ContainerUserDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerUserDataArgs {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
    }
  }
}

pub struct ContainerUserDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerUserDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerUserData::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerUserData::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<UserData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerUserData::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerUserDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerUserDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerUserData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerUserData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerUserData");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.finish()
  }
}
pub enum AnimationAttributeInstanceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnimationAttributeInstance<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnimationAttributeInstance<'a> {
  type Inner = AnimationAttributeInstance<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AnimationAttributeInstance<'a> {
  pub const VT_FLAGS: flatbuffers::VOffsetT = 4;
  pub const VT_PLAYCOUNT: flatbuffers::VOffsetT = 6;
  pub const VT_RATETIME: flatbuffers::VOffsetT = 8;
  pub const VT_OFFSETSTART: flatbuffers::VOffsetT = 10;
  pub const VT_OFFSETEND: flatbuffers::VOffsetT = 12;
  pub const VT_LABELSTART: flatbuffers::VOffsetT = 14;
  pub const VT_LABELEND: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AnimationAttributeInstance { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AnimationAttributeInstanceArgs<'args>
  ) -> flatbuffers::WIPOffset<AnimationAttributeInstance<'bldr>> {
    let mut builder = AnimationAttributeInstanceBuilder::new(_fbb);
    if let Some(x) = args.LabelEnd { builder.add_LabelEnd(x); }
    if let Some(x) = args.LabelStart { builder.add_LabelStart(x); }
    builder.add_OffsetEnd(args.OffsetEnd);
    builder.add_OffsetStart(args.OffsetStart);
    builder.add_RateTime(args.RateTime);
    builder.add_PlayCount(args.PlayCount);
    builder.add_Flags(args.Flags);
    builder.finish()
  }


  #[inline]
  pub fn Flags(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AnimationAttributeInstance::VT_FLAGS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PlayCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AnimationAttributeInstance::VT_PLAYCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RateTime(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AnimationAttributeInstance::VT_RATETIME, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OffsetStart(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AnimationAttributeInstance::VT_OFFSETSTART, Some(0)).unwrap()}
  }
  #[inline]
  pub fn OffsetEnd(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AnimationAttributeInstance::VT_OFFSETEND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn LabelStart(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AnimationAttributeInstance::VT_LABELSTART, None)}
  }
  #[inline]
  pub fn LabelEnd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AnimationAttributeInstance::VT_LABELEND, None)}
  }
}

impl flatbuffers::Verifiable for AnimationAttributeInstance<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("Flags", Self::VT_FLAGS, false)?
     .visit_field::<i32>("PlayCount", Self::VT_PLAYCOUNT, false)?
     .visit_field::<f32>("RateTime", Self::VT_RATETIME, false)?
     .visit_field::<i32>("OffsetStart", Self::VT_OFFSETSTART, false)?
     .visit_field::<i32>("OffsetEnd", Self::VT_OFFSETEND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LabelStart", Self::VT_LABELSTART, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LabelEnd", Self::VT_LABELEND, false)?
     .finish();
    Ok(())
  }
}
pub struct AnimationAttributeInstanceArgs<'a> {
    pub Flags: i32,
    pub PlayCount: i32,
    pub RateTime: f32,
    pub OffsetStart: i32,
    pub OffsetEnd: i32,
    pub LabelStart: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LabelEnd: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AnimationAttributeInstanceArgs<'a> {
  #[inline]
  fn default() -> Self {
    AnimationAttributeInstanceArgs {
      Flags: 0,
      PlayCount: 0,
      RateTime: 0.0,
      OffsetStart: 0,
      OffsetEnd: 0,
      LabelStart: None,
      LabelEnd: None,
    }
  }
}

pub struct AnimationAttributeInstanceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimationAttributeInstanceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Flags(&mut self, Flags: i32) {
    self.fbb_.push_slot::<i32>(AnimationAttributeInstance::VT_FLAGS, Flags, 0);
  }
  #[inline]
  pub fn add_PlayCount(&mut self, PlayCount: i32) {
    self.fbb_.push_slot::<i32>(AnimationAttributeInstance::VT_PLAYCOUNT, PlayCount, 0);
  }
  #[inline]
  pub fn add_RateTime(&mut self, RateTime: f32) {
    self.fbb_.push_slot::<f32>(AnimationAttributeInstance::VT_RATETIME, RateTime, 0.0);
  }
  #[inline]
  pub fn add_OffsetStart(&mut self, OffsetStart: i32) {
    self.fbb_.push_slot::<i32>(AnimationAttributeInstance::VT_OFFSETSTART, OffsetStart, 0);
  }
  #[inline]
  pub fn add_OffsetEnd(&mut self, OffsetEnd: i32) {
    self.fbb_.push_slot::<i32>(AnimationAttributeInstance::VT_OFFSETEND, OffsetEnd, 0);
  }
  #[inline]
  pub fn add_LabelStart(&mut self, LabelStart: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AnimationAttributeInstance::VT_LABELSTART, LabelStart);
  }
  #[inline]
  pub fn add_LabelEnd(&mut self, LabelEnd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AnimationAttributeInstance::VT_LABELEND, LabelEnd);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AnimationAttributeInstanceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AnimationAttributeInstanceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AnimationAttributeInstance<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AnimationAttributeInstance<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AnimationAttributeInstance");
      ds.field("Flags", &self.Flags());
      ds.field("PlayCount", &self.PlayCount());
      ds.field("RateTime", &self.RateTime());
      ds.field("OffsetStart", &self.OffsetStart());
      ds.field("OffsetEnd", &self.OffsetEnd());
      ds.field("LabelStart", &self.LabelStart());
      ds.field("LabelEnd", &self.LabelEnd());
      ds.finish()
  }
}
pub enum ContainerInstanceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerInstance<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerInstance<'a> {
  type Inner = ContainerInstance<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerInstance<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerInstance { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerInstanceArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerInstance<'bldr>> {
    let mut builder = ContainerInstanceBuilder::new(_fbb);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerInstance::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerInstance::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeInstance<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeInstance>>>>(ContainerInstance::VT_TABLEVALUE, None)}
  }
}

impl flatbuffers::Verifiable for ContainerInstance<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnimationAttributeInstance>>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerInstanceArgs<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeInstance<'a>>>>>,
}
impl<'a> Default for ContainerInstanceArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerInstanceArgs {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
    }
  }
}

pub struct ContainerInstanceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerInstanceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerInstance::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerInstance::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AnimationAttributeInstance<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerInstance::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerInstanceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerInstanceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerInstance<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerInstance<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerInstance");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.finish()
  }
}
pub enum AnimationAttributeEffectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnimationAttributeEffect<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnimationAttributeEffect<'a> {
  type Inner = AnimationAttributeEffect<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AnimationAttributeEffect<'a> {
  pub const VT_FLAGS: flatbuffers::VOffsetT = 4;
  pub const VT_FRAMESTART: flatbuffers::VOffsetT = 6;
  pub const VT_RATETIME: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AnimationAttributeEffect { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AnimationAttributeEffectArgs
  ) -> flatbuffers::WIPOffset<AnimationAttributeEffect<'bldr>> {
    let mut builder = AnimationAttributeEffectBuilder::new(_fbb);
    builder.add_RateTime(args.RateTime);
    builder.add_FrameStart(args.FrameStart);
    builder.add_Flags(args.Flags);
    builder.finish()
  }


  #[inline]
  pub fn Flags(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AnimationAttributeEffect::VT_FLAGS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FrameStart(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AnimationAttributeEffect::VT_FRAMESTART, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RateTime(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AnimationAttributeEffect::VT_RATETIME, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AnimationAttributeEffect<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("Flags", Self::VT_FLAGS, false)?
     .visit_field::<i32>("FrameStart", Self::VT_FRAMESTART, false)?
     .visit_field::<f32>("RateTime", Self::VT_RATETIME, false)?
     .finish();
    Ok(())
  }
}
pub struct AnimationAttributeEffectArgs {
    pub Flags: i32,
    pub FrameStart: i32,
    pub RateTime: f32,
}
impl<'a> Default for AnimationAttributeEffectArgs {
  #[inline]
  fn default() -> Self {
    AnimationAttributeEffectArgs {
      Flags: 0,
      FrameStart: 0,
      RateTime: 0.0,
    }
  }
}

pub struct AnimationAttributeEffectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimationAttributeEffectBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Flags(&mut self, Flags: i32) {
    self.fbb_.push_slot::<i32>(AnimationAttributeEffect::VT_FLAGS, Flags, 0);
  }
  #[inline]
  pub fn add_FrameStart(&mut self, FrameStart: i32) {
    self.fbb_.push_slot::<i32>(AnimationAttributeEffect::VT_FRAMESTART, FrameStart, 0);
  }
  #[inline]
  pub fn add_RateTime(&mut self, RateTime: f32) {
    self.fbb_.push_slot::<f32>(AnimationAttributeEffect::VT_RATETIME, RateTime, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AnimationAttributeEffectBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AnimationAttributeEffectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AnimationAttributeEffect<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AnimationAttributeEffect<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AnimationAttributeEffect");
      ds.field("Flags", &self.Flags());
      ds.field("FrameStart", &self.FrameStart());
      ds.field("RateTime", &self.RateTime());
      ds.finish()
  }
}
pub enum ContainerEffectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerEffect<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerEffect<'a> {
  type Inner = ContainerEffect<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerEffect<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerEffect { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerEffectArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerEffect<'bldr>> {
    let mut builder = ContainerEffectBuilder::new(_fbb);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerEffect::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerEffect::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeEffect<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeEffect>>>>(ContainerEffect::VT_TABLEVALUE, None)}
  }
}

impl flatbuffers::Verifiable for ContainerEffect<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnimationAttributeEffect>>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerEffectArgs<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeEffect<'a>>>>>,
}
impl<'a> Default for ContainerEffectArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerEffectArgs {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
    }
  }
}

pub struct ContainerEffectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerEffectBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerEffect::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerEffect::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AnimationAttributeEffect<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerEffect::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerEffectBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerEffectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerEffect<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerEffect<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerEffect");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.finish()
  }
}
pub enum AnimationAttributeDeformOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnimationAttributeDeform<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnimationAttributeDeform<'a> {
  type Inner = AnimationAttributeDeform<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AnimationAttributeDeform<'a> {
  pub const VT_TABLECOORDINATE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AnimationAttributeDeform { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AnimationAttributeDeformArgs<'args>
  ) -> flatbuffers::WIPOffset<AnimationAttributeDeform<'bldr>> {
    let mut builder = AnimationAttributeDeformBuilder::new(_fbb);
    if let Some(x) = args.TableCoordinate { builder.add_TableCoordinate(x); }
    builder.finish()
  }


  #[inline]
  pub fn TableCoordinate(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2>>>>(AnimationAttributeDeform::VT_TABLECOORDINATE, None)}
  }
}

impl flatbuffers::Verifiable for AnimationAttributeDeform<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Vector2>>>>("TableCoordinate", Self::VT_TABLECOORDINATE, false)?
     .finish();
    Ok(())
  }
}
pub struct AnimationAttributeDeformArgs<'a> {
    pub TableCoordinate: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vector2<'a>>>>>,
}
impl<'a> Default for AnimationAttributeDeformArgs<'a> {
  #[inline]
  fn default() -> Self {
    AnimationAttributeDeformArgs {
      TableCoordinate: None,
    }
  }
}

pub struct AnimationAttributeDeformBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimationAttributeDeformBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TableCoordinate(&mut self, TableCoordinate: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Vector2<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AnimationAttributeDeform::VT_TABLECOORDINATE, TableCoordinate);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AnimationAttributeDeformBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AnimationAttributeDeformBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AnimationAttributeDeform<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AnimationAttributeDeform<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AnimationAttributeDeform");
      ds.field("TableCoordinate", &self.TableCoordinate());
      ds.finish()
  }
}
pub enum AnimationAttributeShaderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnimationAttributeShader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnimationAttributeShader<'a> {
  type Inner = AnimationAttributeShader<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AnimationAttributeShader<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PARAMETER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AnimationAttributeShader { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AnimationAttributeShaderArgs<'args>
  ) -> flatbuffers::WIPOffset<AnimationAttributeShader<'bldr>> {
    let mut builder = AnimationAttributeShaderBuilder::new(_fbb);
    if let Some(x) = args.Parameter { builder.add_Parameter(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.finish()
  }


  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AnimationAttributeShader::VT_ID, None)}
  }
  #[inline]
  pub fn Parameter(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(AnimationAttributeShader::VT_PARAMETER, None)}
  }
}

impl flatbuffers::Verifiable for AnimationAttributeShader<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("Parameter", Self::VT_PARAMETER, false)?
     .finish();
    Ok(())
  }
}
pub struct AnimationAttributeShaderArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub Parameter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for AnimationAttributeShaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    AnimationAttributeShaderArgs {
      ID: None,
      Parameter: None,
    }
  }
}

pub struct AnimationAttributeShaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimationAttributeShaderBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AnimationAttributeShader::VT_ID, ID);
  }
  #[inline]
  pub fn add_Parameter(&mut self, Parameter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AnimationAttributeShader::VT_PARAMETER, Parameter);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AnimationAttributeShaderBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AnimationAttributeShaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AnimationAttributeShader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AnimationAttributeShader<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AnimationAttributeShader");
      ds.field("ID", &self.ID());
      ds.field("Parameter", &self.Parameter());
      ds.finish()
  }
}
pub enum AnimationAttributeSignalCommandParameterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnimationAttributeSignalCommandParameter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnimationAttributeSignalCommandParameter<'a> {
  type Inner = AnimationAttributeSignalCommandParameter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AnimationAttributeSignalCommandParameter<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_DATA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AnimationAttributeSignalCommandParameter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AnimationAttributeSignalCommandParameterArgs<'args>
  ) -> flatbuffers::WIPOffset<AnimationAttributeSignalCommandParameter<'bldr>> {
    let mut builder = AnimationAttributeSignalCommandParameterBuilder::new(_fbb);
    if let Some(x) = args.Data { builder.add_Data(x); }
    builder.add_Type(args.Type);
    builder.add_ID(args.ID);
    builder.finish()
  }


  #[inline]
  pub fn ID(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AnimationAttributeSignalCommandParameter::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Type(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AnimationAttributeSignalCommandParameter::VT_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Data(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AnimationAttributeSignalCommandParameter::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for AnimationAttributeSignalCommandParameter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("ID", Self::VT_ID, false)?
     .visit_field::<i32>("Type", Self::VT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("Data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct AnimationAttributeSignalCommandParameterArgs<'a> {
    pub ID: i32,
    pub Type: i32,
    pub Data: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AnimationAttributeSignalCommandParameterArgs<'a> {
  #[inline]
  fn default() -> Self {
    AnimationAttributeSignalCommandParameterArgs {
      ID: 0,
      Type: 0,
      Data: None,
    }
  }
}

pub struct AnimationAttributeSignalCommandParameterBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimationAttributeSignalCommandParameterBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: i32) {
    self.fbb_.push_slot::<i32>(AnimationAttributeSignalCommandParameter::VT_ID, ID, 0);
  }
  #[inline]
  pub fn add_Type(&mut self, Type: i32) {
    self.fbb_.push_slot::<i32>(AnimationAttributeSignalCommandParameter::VT_TYPE, Type, 0);
  }
  #[inline]
  pub fn add_Data(&mut self, Data: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AnimationAttributeSignalCommandParameter::VT_DATA, Data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AnimationAttributeSignalCommandParameterBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AnimationAttributeSignalCommandParameterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AnimationAttributeSignalCommandParameter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AnimationAttributeSignalCommandParameter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AnimationAttributeSignalCommandParameter");
      ds.field("ID", &self.ID());
      ds.field("Type", &self.Type());
      ds.field("Data", &self.Data());
      ds.finish()
  }
}
pub enum AnimationAttributeSignalCommandOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnimationAttributeSignalCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnimationAttributeSignalCommand<'a> {
  type Inner = AnimationAttributeSignalCommand<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AnimationAttributeSignalCommand<'a> {
  pub const VT_FLAGS: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_NOTE: flatbuffers::VOffsetT = 8;
  pub const VT_TABLEPARAMETER: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AnimationAttributeSignalCommand { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AnimationAttributeSignalCommandArgs<'args>
  ) -> flatbuffers::WIPOffset<AnimationAttributeSignalCommand<'bldr>> {
    let mut builder = AnimationAttributeSignalCommandBuilder::new(_fbb);
    if let Some(x) = args.TableParameter { builder.add_TableParameter(x); }
    if let Some(x) = args.Note { builder.add_Note(x); }
    builder.add_ID(args.ID);
    builder.add_Flags(args.Flags);
    builder.finish()
  }


  #[inline]
  pub fn Flags(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AnimationAttributeSignalCommand::VT_FLAGS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ID(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AnimationAttributeSignalCommand::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Note(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AnimationAttributeSignalCommand::VT_NOTE, None)}
  }
  #[inline]
  pub fn TableParameter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeSignalCommandParameter<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeSignalCommandParameter>>>>(AnimationAttributeSignalCommand::VT_TABLEPARAMETER, None)}
  }
}

impl flatbuffers::Verifiable for AnimationAttributeSignalCommand<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("Flags", Self::VT_FLAGS, false)?
     .visit_field::<i32>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("Note", Self::VT_NOTE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnimationAttributeSignalCommandParameter>>>>("TableParameter", Self::VT_TABLEPARAMETER, false)?
     .finish();
    Ok(())
  }
}
pub struct AnimationAttributeSignalCommandArgs<'a> {
    pub Flags: i32,
    pub ID: i32,
    pub Note: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TableParameter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeSignalCommandParameter<'a>>>>>,
}
impl<'a> Default for AnimationAttributeSignalCommandArgs<'a> {
  #[inline]
  fn default() -> Self {
    AnimationAttributeSignalCommandArgs {
      Flags: 0,
      ID: 0,
      Note: None,
      TableParameter: None,
    }
  }
}

pub struct AnimationAttributeSignalCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimationAttributeSignalCommandBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Flags(&mut self, Flags: i32) {
    self.fbb_.push_slot::<i32>(AnimationAttributeSignalCommand::VT_FLAGS, Flags, 0);
  }
  #[inline]
  pub fn add_ID(&mut self, ID: i32) {
    self.fbb_.push_slot::<i32>(AnimationAttributeSignalCommand::VT_ID, ID, 0);
  }
  #[inline]
  pub fn add_Note(&mut self, Note: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AnimationAttributeSignalCommand::VT_NOTE, Note);
  }
  #[inline]
  pub fn add_TableParameter(&mut self, TableParameter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AnimationAttributeSignalCommandParameter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AnimationAttributeSignalCommand::VT_TABLEPARAMETER, TableParameter);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AnimationAttributeSignalCommandBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AnimationAttributeSignalCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AnimationAttributeSignalCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AnimationAttributeSignalCommand<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AnimationAttributeSignalCommand");
      ds.field("Flags", &self.Flags());
      ds.field("ID", &self.ID());
      ds.field("Note", &self.Note());
      ds.field("TableParameter", &self.TableParameter());
      ds.finish()
  }
}
pub enum AnimationAttributeSignalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnimationAttributeSignal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnimationAttributeSignal<'a> {
  type Inner = AnimationAttributeSignal<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AnimationAttributeSignal<'a> {
  pub const VT_TABLECOMMAND: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AnimationAttributeSignal { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AnimationAttributeSignalArgs<'args>
  ) -> flatbuffers::WIPOffset<AnimationAttributeSignal<'bldr>> {
    let mut builder = AnimationAttributeSignalBuilder::new(_fbb);
    if let Some(x) = args.TableCommand { builder.add_TableCommand(x); }
    builder.finish()
  }


  #[inline]
  pub fn TableCommand(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeSignalCommand<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeSignalCommand>>>>(AnimationAttributeSignal::VT_TABLECOMMAND, None)}
  }
}

impl flatbuffers::Verifiable for AnimationAttributeSignal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnimationAttributeSignalCommand>>>>("TableCommand", Self::VT_TABLECOMMAND, false)?
     .finish();
    Ok(())
  }
}
pub struct AnimationAttributeSignalArgs<'a> {
    pub TableCommand: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeSignalCommand<'a>>>>>,
}
impl<'a> Default for AnimationAttributeSignalArgs<'a> {
  #[inline]
  fn default() -> Self {
    AnimationAttributeSignalArgs {
      TableCommand: None,
    }
  }
}

pub struct AnimationAttributeSignalBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimationAttributeSignalBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TableCommand(&mut self, TableCommand: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AnimationAttributeSignalCommand<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AnimationAttributeSignal::VT_TABLECOMMAND, TableCommand);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AnimationAttributeSignalBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AnimationAttributeSignalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AnimationAttributeSignal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AnimationAttributeSignal<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AnimationAttributeSignal");
      ds.field("TableCommand", &self.TableCommand());
      ds.finish()
  }
}
pub enum ContainerDeformOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerDeform<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerDeform<'a> {
  type Inner = ContainerDeform<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerDeform<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;
  pub const VT_COUNTVERTEXMESH: flatbuffers::VOffsetT = 10;
  pub const VT_TABLEINDEXVERTEX: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerDeform { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerDeformArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerDeform<'bldr>> {
    let mut builder = ContainerDeformBuilder::new(_fbb);
    if let Some(x) = args.TableIndexVertex { builder.add_TableIndexVertex(x); }
    builder.add_CountVertexMesh(args.CountVertexMesh);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerDeform::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerDeform::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeDeform<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeDeform>>>>(ContainerDeform::VT_TABLEVALUE, None)}
  }
  #[inline]
  pub fn CountVertexMesh(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ContainerDeform::VT_COUNTVERTEXMESH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TableIndexVertex(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(ContainerDeform::VT_TABLEINDEXVERTEX, None)}
  }
}

impl flatbuffers::Verifiable for ContainerDeform<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnimationAttributeDeform>>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .visit_field::<i32>("CountVertexMesh", Self::VT_COUNTVERTEXMESH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("TableIndexVertex", Self::VT_TABLEINDEXVERTEX, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerDeformArgs<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeDeform<'a>>>>>,
    pub CountVertexMesh: i32,
    pub TableIndexVertex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for ContainerDeformArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerDeformArgs {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
      CountVertexMesh: 0,
      TableIndexVertex: None,
    }
  }
}

pub struct ContainerDeformBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerDeformBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerDeform::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerDeform::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AnimationAttributeDeform<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerDeform::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn add_CountVertexMesh(&mut self, CountVertexMesh: i32) {
    self.fbb_.push_slot::<i32>(ContainerDeform::VT_COUNTVERTEXMESH, CountVertexMesh, 0);
  }
  #[inline]
  pub fn add_TableIndexVertex(&mut self, TableIndexVertex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerDeform::VT_TABLEINDEXVERTEX, TableIndexVertex);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerDeformBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerDeformBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerDeform<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerDeform<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerDeform");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.field("CountVertexMesh", &self.CountVertexMesh());
      ds.field("TableIndexVertex", &self.TableIndexVertex());
      ds.finish()
  }
}
pub enum ContainerShaderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerShader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerShader<'a> {
  type Inner = ContainerShader<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerShader<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerShader { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerShaderArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerShader<'bldr>> {
    let mut builder = ContainerShaderBuilder::new(_fbb);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerShader::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerShader::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeShader<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeShader>>>>(ContainerShader::VT_TABLEVALUE, None)}
  }
}

impl flatbuffers::Verifiable for ContainerShader<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnimationAttributeShader>>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerShaderArgs<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeShader<'a>>>>>,
}
impl<'a> Default for ContainerShaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerShaderArgs {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
    }
  }
}

pub struct ContainerShaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerShaderBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerShader::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerShader::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AnimationAttributeShader<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerShader::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerShaderBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerShaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerShader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerShader<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerShader");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.finish()
  }
}
pub enum ContainerSignalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContainerSignal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerSignal<'a> {
  type Inner = ContainerSignal<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerSignal<'a> {
  pub const VT_TYPEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_TABLECODEVALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TABLEVALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerSignal { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerSignalArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerSignal<'bldr>> {
    let mut builder = ContainerSignalBuilder::new(_fbb);
    if let Some(x) = args.TableValue { builder.add_TableValue(x); }
    if let Some(x) = args.TableCodeValue { builder.add_TableCodeValue(x); }
    builder.add_TypePack(args.TypePack);
    builder.finish()
  }


  #[inline]
  pub fn TypePack(&self) -> KindTypePack {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindTypePack>(ContainerSignal::VT_TYPEPACK, Some(KindTypePack::STANDARD_UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn TableCodeValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>(ContainerSignal::VT_TABLECODEVALUE, None)}
  }
  #[inline]
  pub fn TableValue(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeSignal<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeSignal>>>>(ContainerSignal::VT_TABLEVALUE, None)}
  }
}

impl flatbuffers::Verifiable for ContainerSignal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KindTypePack>("TypePack", Self::VT_TYPEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CodeValueContainer>>>>("TableCodeValue", Self::VT_TABLECODEVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnimationAttributeSignal>>>>("TableValue", Self::VT_TABLEVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerSignalArgs<'a> {
    pub TypePack: KindTypePack,
    pub TableCodeValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CodeValueContainer<'a>>>>>,
    pub TableValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationAttributeSignal<'a>>>>>,
}
impl<'a> Default for ContainerSignalArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerSignalArgs {
      TypePack: KindTypePack::STANDARD_UNCOMPRESSED,
      TableCodeValue: None,
      TableValue: None,
    }
  }
}

pub struct ContainerSignalBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerSignalBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TypePack(&mut self, TypePack: KindTypePack) {
    self.fbb_.push_slot::<KindTypePack>(ContainerSignal::VT_TYPEPACK, TypePack, KindTypePack::STANDARD_UNCOMPRESSED);
  }
  #[inline]
  pub fn add_TableCodeValue(&mut self, TableCodeValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CodeValueContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerSignal::VT_TABLECODEVALUE, TableCodeValue);
  }
  #[inline]
  pub fn add_TableValue(&mut self, TableValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AnimationAttributeSignal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerSignal::VT_TABLEVALUE, TableValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerSignalBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerSignalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerSignal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerSignal<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerSignal");
      ds.field("TypePack", &self.TypePack());
      ds.field("TableCodeValue", &self.TableCodeValue());
      ds.field("TableValue", &self.TableValue());
      ds.finish()
  }
}
pub enum DataAnimationPartsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataAnimationParts<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataAnimationParts<'a> {
  type Inner = DataAnimationParts<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataAnimationParts<'a> {
  pub const VT_STATUS_PARTS: flatbuffers::VOffsetT = 4;
  pub const VT_STATUS: flatbuffers::VOffsetT = 6;
  pub const VT_CELL: flatbuffers::VOffsetT = 8;
  pub const VT_POSITION: flatbuffers::VOffsetT = 10;
  pub const VT_ROTATION: flatbuffers::VOffsetT = 12;
  pub const VT_SCALING: flatbuffers::VOffsetT = 14;
  pub const VT_SCALINGLOCAL: flatbuffers::VOffsetT = 16;
  pub const VT_RATEOPACITY: flatbuffers::VOffsetT = 18;
  pub const VT_PRIORITY: flatbuffers::VOffsetT = 20;
  pub const VT_PARTSCOLOR: flatbuffers::VOffsetT = 22;
  pub const VT_VERTEXCORRECTION: flatbuffers::VOffsetT = 24;
  pub const VT_OFFSETPIVOT: flatbuffers::VOffsetT = 26;
  pub const VT_POSITIONANCHOR: flatbuffers::VOffsetT = 28;
  pub const VT_SIZEFORCE: flatbuffers::VOffsetT = 30;
  pub const VT_POSITIONTEXTURE: flatbuffers::VOffsetT = 32;
  pub const VT_ROTATIONTEXTURE: flatbuffers::VOffsetT = 34;
  pub const VT_SCALINGTEXTURE: flatbuffers::VOffsetT = 36;
  pub const VT_RADIUSCOLLISION: flatbuffers::VOffsetT = 38;
  pub const VT_USER_DATA: flatbuffers::VOffsetT = 40;
  pub const VT_INSTANCE: flatbuffers::VOffsetT = 42;
  pub const VT_EFFECT: flatbuffers::VOffsetT = 44;
  pub const VT_DEFORM: flatbuffers::VOffsetT = 46;
  pub const VT_SHADER: flatbuffers::VOffsetT = 48;
  pub const VT_SIGNAL: flatbuffers::VOffsetT = 50;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataAnimationParts { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataAnimationPartsArgs<'args>
  ) -> flatbuffers::WIPOffset<DataAnimationParts<'bldr>> {
    let mut builder = DataAnimationPartsBuilder::new(_fbb);
    if let Some(x) = args.signal { builder.add_signal(x); }
    if let Some(x) = args.shader { builder.add_shader(x); }
    if let Some(x) = args.deform { builder.add_deform(x); }
    if let Some(x) = args.effect { builder.add_effect(x); }
    if let Some(x) = args.instance { builder.add_instance(x); }
    if let Some(x) = args.user_data { builder.add_user_data(x); }
    if let Some(x) = args.radiusCollision { builder.add_radiusCollision(x); }
    if let Some(x) = args.scalingTexture { builder.add_scalingTexture(x); }
    if let Some(x) = args.rotationTexture { builder.add_rotationTexture(x); }
    if let Some(x) = args.positionTexture { builder.add_positionTexture(x); }
    if let Some(x) = args.sizeForce { builder.add_sizeForce(x); }
    if let Some(x) = args.positionAnchor { builder.add_positionAnchor(x); }
    if let Some(x) = args.offsetPivot { builder.add_offsetPivot(x); }
    if let Some(x) = args.vertexCorrection { builder.add_vertexCorrection(x); }
    if let Some(x) = args.partsColor { builder.add_partsColor(x); }
    if let Some(x) = args.priority { builder.add_priority(x); }
    if let Some(x) = args.rateOpacity { builder.add_rateOpacity(x); }
    if let Some(x) = args.scalingLocal { builder.add_scalingLocal(x); }
    if let Some(x) = args.scaling { builder.add_scaling(x); }
    if let Some(x) = args.rotation { builder.add_rotation(x); }
    if let Some(x) = args.position { builder.add_position(x); }
    if let Some(x) = args.cell { builder.add_cell(x); }
    if let Some(x) = args.status { builder.add_status(x); }
    builder.add_status_parts(args.status_parts);
    builder.finish()
  }


  #[inline]
  pub fn status_parts(&self) -> DataAnimationPartsFlagBitStatus {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DataAnimationPartsFlagBitStatus>(DataAnimationParts::VT_STATUS_PARTS, Some(DataAnimationPartsFlagBitStatus::Clear)).unwrap()}
  }
  #[inline]
  pub fn status(&self) -> Option<ContainerStatus<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerStatus>>(DataAnimationParts::VT_STATUS, None)}
  }
  #[inline]
  pub fn cell(&self) -> Option<ContainerCell<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerCell>>(DataAnimationParts::VT_CELL, None)}
  }
  #[inline]
  pub fn position(&self) -> Option<ContainerVector3<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerVector3>>(DataAnimationParts::VT_POSITION, None)}
  }
  #[inline]
  pub fn rotation(&self) -> Option<ContainerVector3<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerVector3>>(DataAnimationParts::VT_ROTATION, None)}
  }
  #[inline]
  pub fn scaling(&self) -> Option<ContainerVector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerVector2>>(DataAnimationParts::VT_SCALING, None)}
  }
  #[inline]
  pub fn scalingLocal(&self) -> Option<ContainerVector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerVector2>>(DataAnimationParts::VT_SCALINGLOCAL, None)}
  }
  #[inline]
  pub fn rateOpacity(&self) -> Option<ContainerFloat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerFloat>>(DataAnimationParts::VT_RATEOPACITY, None)}
  }
  #[inline]
  pub fn priority(&self) -> Option<ContainerInt<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerInt>>(DataAnimationParts::VT_PRIORITY, None)}
  }
  #[inline]
  pub fn partsColor(&self) -> Option<ContainerPartsColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerPartsColor>>(DataAnimationParts::VT_PARTSCOLOR, None)}
  }
  #[inline]
  pub fn vertexCorrection(&self) -> Option<ContainerVertexCorrection<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerVertexCorrection>>(DataAnimationParts::VT_VERTEXCORRECTION, None)}
  }
  #[inline]
  pub fn offsetPivot(&self) -> Option<ContainerVector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerVector2>>(DataAnimationParts::VT_OFFSETPIVOT, None)}
  }
  #[inline]
  pub fn positionAnchor(&self) -> Option<ContainerVector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerVector2>>(DataAnimationParts::VT_POSITIONANCHOR, None)}
  }
  #[inline]
  pub fn sizeForce(&self) -> Option<ContainerVector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerVector2>>(DataAnimationParts::VT_SIZEFORCE, None)}
  }
  #[inline]
  pub fn positionTexture(&self) -> Option<ContainerVector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerVector2>>(DataAnimationParts::VT_POSITIONTEXTURE, None)}
  }
  #[inline]
  pub fn rotationTexture(&self) -> Option<ContainerFloat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerFloat>>(DataAnimationParts::VT_ROTATIONTEXTURE, None)}
  }
  #[inline]
  pub fn scalingTexture(&self) -> Option<ContainerVector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerVector2>>(DataAnimationParts::VT_SCALINGTEXTURE, None)}
  }
  #[inline]
  pub fn radiusCollision(&self) -> Option<ContainerFloat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerFloat>>(DataAnimationParts::VT_RADIUSCOLLISION, None)}
  }
  #[inline]
  pub fn user_data(&self) -> Option<ContainerUserData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerUserData>>(DataAnimationParts::VT_USER_DATA, None)}
  }
  #[inline]
  pub fn instance(&self) -> Option<ContainerInstance<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerInstance>>(DataAnimationParts::VT_INSTANCE, None)}
  }
  #[inline]
  pub fn effect(&self) -> Option<ContainerEffect<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerEffect>>(DataAnimationParts::VT_EFFECT, None)}
  }
  #[inline]
  pub fn deform(&self) -> Option<ContainerDeform<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerDeform>>(DataAnimationParts::VT_DEFORM, None)}
  }
  #[inline]
  pub fn shader(&self) -> Option<ContainerShader<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerShader>>(DataAnimationParts::VT_SHADER, None)}
  }
  #[inline]
  pub fn signal(&self) -> Option<ContainerSignal<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerSignal>>(DataAnimationParts::VT_SIGNAL, None)}
  }
}

impl flatbuffers::Verifiable for DataAnimationParts<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<DataAnimationPartsFlagBitStatus>("status_parts", Self::VT_STATUS_PARTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerStatus>>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerCell>>("cell", Self::VT_CELL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerVector3>>("position", Self::VT_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerVector3>>("rotation", Self::VT_ROTATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerVector2>>("scaling", Self::VT_SCALING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerVector2>>("scalingLocal", Self::VT_SCALINGLOCAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerFloat>>("rateOpacity", Self::VT_RATEOPACITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerInt>>("priority", Self::VT_PRIORITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerPartsColor>>("partsColor", Self::VT_PARTSCOLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerVertexCorrection>>("vertexCorrection", Self::VT_VERTEXCORRECTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerVector2>>("offsetPivot", Self::VT_OFFSETPIVOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerVector2>>("positionAnchor", Self::VT_POSITIONANCHOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerVector2>>("sizeForce", Self::VT_SIZEFORCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerVector2>>("positionTexture", Self::VT_POSITIONTEXTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerFloat>>("rotationTexture", Self::VT_ROTATIONTEXTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerVector2>>("scalingTexture", Self::VT_SCALINGTEXTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerFloat>>("radiusCollision", Self::VT_RADIUSCOLLISION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerUserData>>("user_data", Self::VT_USER_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerInstance>>("instance", Self::VT_INSTANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerEffect>>("effect", Self::VT_EFFECT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerDeform>>("deform", Self::VT_DEFORM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerShader>>("shader", Self::VT_SHADER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerSignal>>("signal", Self::VT_SIGNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct DataAnimationPartsArgs<'a> {
    pub status_parts: DataAnimationPartsFlagBitStatus,
    pub status: Option<flatbuffers::WIPOffset<ContainerStatus<'a>>>,
    pub cell: Option<flatbuffers::WIPOffset<ContainerCell<'a>>>,
    pub position: Option<flatbuffers::WIPOffset<ContainerVector3<'a>>>,
    pub rotation: Option<flatbuffers::WIPOffset<ContainerVector3<'a>>>,
    pub scaling: Option<flatbuffers::WIPOffset<ContainerVector2<'a>>>,
    pub scalingLocal: Option<flatbuffers::WIPOffset<ContainerVector2<'a>>>,
    pub rateOpacity: Option<flatbuffers::WIPOffset<ContainerFloat<'a>>>,
    pub priority: Option<flatbuffers::WIPOffset<ContainerInt<'a>>>,
    pub partsColor: Option<flatbuffers::WIPOffset<ContainerPartsColor<'a>>>,
    pub vertexCorrection: Option<flatbuffers::WIPOffset<ContainerVertexCorrection<'a>>>,
    pub offsetPivot: Option<flatbuffers::WIPOffset<ContainerVector2<'a>>>,
    pub positionAnchor: Option<flatbuffers::WIPOffset<ContainerVector2<'a>>>,
    pub sizeForce: Option<flatbuffers::WIPOffset<ContainerVector2<'a>>>,
    pub positionTexture: Option<flatbuffers::WIPOffset<ContainerVector2<'a>>>,
    pub rotationTexture: Option<flatbuffers::WIPOffset<ContainerFloat<'a>>>,
    pub scalingTexture: Option<flatbuffers::WIPOffset<ContainerVector2<'a>>>,
    pub radiusCollision: Option<flatbuffers::WIPOffset<ContainerFloat<'a>>>,
    pub user_data: Option<flatbuffers::WIPOffset<ContainerUserData<'a>>>,
    pub instance: Option<flatbuffers::WIPOffset<ContainerInstance<'a>>>,
    pub effect: Option<flatbuffers::WIPOffset<ContainerEffect<'a>>>,
    pub deform: Option<flatbuffers::WIPOffset<ContainerDeform<'a>>>,
    pub shader: Option<flatbuffers::WIPOffset<ContainerShader<'a>>>,
    pub signal: Option<flatbuffers::WIPOffset<ContainerSignal<'a>>>,
}
impl<'a> Default for DataAnimationPartsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataAnimationPartsArgs {
      status_parts: DataAnimationPartsFlagBitStatus::Clear,
      status: None,
      cell: None,
      position: None,
      rotation: None,
      scaling: None,
      scalingLocal: None,
      rateOpacity: None,
      priority: None,
      partsColor: None,
      vertexCorrection: None,
      offsetPivot: None,
      positionAnchor: None,
      sizeForce: None,
      positionTexture: None,
      rotationTexture: None,
      scalingTexture: None,
      radiusCollision: None,
      user_data: None,
      instance: None,
      effect: None,
      deform: None,
      shader: None,
      signal: None,
    }
  }
}

pub struct DataAnimationPartsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataAnimationPartsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_status_parts(&mut self, status_parts: DataAnimationPartsFlagBitStatus) {
    self.fbb_.push_slot::<DataAnimationPartsFlagBitStatus>(DataAnimationParts::VT_STATUS_PARTS, status_parts, DataAnimationPartsFlagBitStatus::Clear);
  }
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<ContainerStatus<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerStatus>>(DataAnimationParts::VT_STATUS, status);
  }
  #[inline]
  pub fn add_cell(&mut self, cell: flatbuffers::WIPOffset<ContainerCell<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerCell>>(DataAnimationParts::VT_CELL, cell);
  }
  #[inline]
  pub fn add_position(&mut self, position: flatbuffers::WIPOffset<ContainerVector3<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerVector3>>(DataAnimationParts::VT_POSITION, position);
  }
  #[inline]
  pub fn add_rotation(&mut self, rotation: flatbuffers::WIPOffset<ContainerVector3<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerVector3>>(DataAnimationParts::VT_ROTATION, rotation);
  }
  #[inline]
  pub fn add_scaling(&mut self, scaling: flatbuffers::WIPOffset<ContainerVector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerVector2>>(DataAnimationParts::VT_SCALING, scaling);
  }
  #[inline]
  pub fn add_scalingLocal(&mut self, scalingLocal: flatbuffers::WIPOffset<ContainerVector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerVector2>>(DataAnimationParts::VT_SCALINGLOCAL, scalingLocal);
  }
  #[inline]
  pub fn add_rateOpacity(&mut self, rateOpacity: flatbuffers::WIPOffset<ContainerFloat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerFloat>>(DataAnimationParts::VT_RATEOPACITY, rateOpacity);
  }
  #[inline]
  pub fn add_priority(&mut self, priority: flatbuffers::WIPOffset<ContainerInt<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerInt>>(DataAnimationParts::VT_PRIORITY, priority);
  }
  #[inline]
  pub fn add_partsColor(&mut self, partsColor: flatbuffers::WIPOffset<ContainerPartsColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerPartsColor>>(DataAnimationParts::VT_PARTSCOLOR, partsColor);
  }
  #[inline]
  pub fn add_vertexCorrection(&mut self, vertexCorrection: flatbuffers::WIPOffset<ContainerVertexCorrection<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerVertexCorrection>>(DataAnimationParts::VT_VERTEXCORRECTION, vertexCorrection);
  }
  #[inline]
  pub fn add_offsetPivot(&mut self, offsetPivot: flatbuffers::WIPOffset<ContainerVector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerVector2>>(DataAnimationParts::VT_OFFSETPIVOT, offsetPivot);
  }
  #[inline]
  pub fn add_positionAnchor(&mut self, positionAnchor: flatbuffers::WIPOffset<ContainerVector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerVector2>>(DataAnimationParts::VT_POSITIONANCHOR, positionAnchor);
  }
  #[inline]
  pub fn add_sizeForce(&mut self, sizeForce: flatbuffers::WIPOffset<ContainerVector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerVector2>>(DataAnimationParts::VT_SIZEFORCE, sizeForce);
  }
  #[inline]
  pub fn add_positionTexture(&mut self, positionTexture: flatbuffers::WIPOffset<ContainerVector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerVector2>>(DataAnimationParts::VT_POSITIONTEXTURE, positionTexture);
  }
  #[inline]
  pub fn add_rotationTexture(&mut self, rotationTexture: flatbuffers::WIPOffset<ContainerFloat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerFloat>>(DataAnimationParts::VT_ROTATIONTEXTURE, rotationTexture);
  }
  #[inline]
  pub fn add_scalingTexture(&mut self, scalingTexture: flatbuffers::WIPOffset<ContainerVector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerVector2>>(DataAnimationParts::VT_SCALINGTEXTURE, scalingTexture);
  }
  #[inline]
  pub fn add_radiusCollision(&mut self, radiusCollision: flatbuffers::WIPOffset<ContainerFloat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerFloat>>(DataAnimationParts::VT_RADIUSCOLLISION, radiusCollision);
  }
  #[inline]
  pub fn add_user_data(&mut self, user_data: flatbuffers::WIPOffset<ContainerUserData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerUserData>>(DataAnimationParts::VT_USER_DATA, user_data);
  }
  #[inline]
  pub fn add_instance(&mut self, instance: flatbuffers::WIPOffset<ContainerInstance<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerInstance>>(DataAnimationParts::VT_INSTANCE, instance);
  }
  #[inline]
  pub fn add_effect(&mut self, effect: flatbuffers::WIPOffset<ContainerEffect<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerEffect>>(DataAnimationParts::VT_EFFECT, effect);
  }
  #[inline]
  pub fn add_deform(&mut self, deform: flatbuffers::WIPOffset<ContainerDeform<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerDeform>>(DataAnimationParts::VT_DEFORM, deform);
  }
  #[inline]
  pub fn add_shader(&mut self, shader: flatbuffers::WIPOffset<ContainerShader<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerShader>>(DataAnimationParts::VT_SHADER, shader);
  }
  #[inline]
  pub fn add_signal(&mut self, signal: flatbuffers::WIPOffset<ContainerSignal<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerSignal>>(DataAnimationParts::VT_SIGNAL, signal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataAnimationPartsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataAnimationPartsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataAnimationParts<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataAnimationParts<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataAnimationParts");
      ds.field("status_parts", &self.status_parts());
      ds.field("status", &self.status());
      ds.field("cell", &self.cell());
      ds.field("position", &self.position());
      ds.field("rotation", &self.rotation());
      ds.field("scaling", &self.scaling());
      ds.field("scalingLocal", &self.scalingLocal());
      ds.field("rateOpacity", &self.rateOpacity());
      ds.field("priority", &self.priority());
      ds.field("partsColor", &self.partsColor());
      ds.field("vertexCorrection", &self.vertexCorrection());
      ds.field("offsetPivot", &self.offsetPivot());
      ds.field("positionAnchor", &self.positionAnchor());
      ds.field("sizeForce", &self.sizeForce());
      ds.field("positionTexture", &self.positionTexture());
      ds.field("rotationTexture", &self.rotationTexture());
      ds.field("scalingTexture", &self.scalingTexture());
      ds.field("radiusCollision", &self.radiusCollision());
      ds.field("user_data", &self.user_data());
      ds.field("instance", &self.instance());
      ds.field("effect", &self.effect());
      ds.field("deform", &self.deform());
      ds.field("shader", &self.shader());
      ds.field("signal", &self.signal());
      ds.finish()
  }
}
pub enum LibraryDataAnimationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LibraryDataAnimation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LibraryDataAnimation<'a> {
  type Inner = LibraryDataAnimation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LibraryDataAnimation<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_FRAME_PER_SECOND: flatbuffers::VOffsetT = 6;
  pub const VT_COUNT_FRAME: flatbuffers::VOffsetT = 8;
  pub const VT_SIZE_CANVAS_X: flatbuffers::VOffsetT = 10;
  pub const VT_SIZE_CANVAS_Y: flatbuffers::VOffsetT = 12;
  pub const VT_FRAME_VALID_START: flatbuffers::VOffsetT = 14;
  pub const VT_FRAME_VALID_END: flatbuffers::VOffsetT = 16;
  pub const VT_COUNT_FRAME_VALID: flatbuffers::VOffsetT = 18;
  pub const VT_DEPTH_IK: flatbuffers::VOffsetT = 20;
  pub const VT_MODE_SORT: flatbuffers::VOffsetT = 22;
  pub const VT_TABLE_LABEL: flatbuffers::VOffsetT = 24;
  pub const VT_TABLE_PARTS: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LibraryDataAnimation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LibraryDataAnimationArgs<'args>
  ) -> flatbuffers::WIPOffset<LibraryDataAnimation<'bldr>> {
    let mut builder = LibraryDataAnimationBuilder::new(_fbb);
    if let Some(x) = args.table_parts { builder.add_table_parts(x); }
    if let Some(x) = args.table_label { builder.add_table_label(x); }
    builder.add_depth_ik(args.depth_ik);
    builder.add_count_frame_valid(args.count_frame_valid);
    builder.add_frame_valid_end(args.frame_valid_end);
    builder.add_frame_valid_start(args.frame_valid_start);
    builder.add_size_canvas_y(args.size_canvas_y);
    builder.add_size_canvas_x(args.size_canvas_x);
    builder.add_count_frame(args.count_frame);
    builder.add_frame_per_second(args.frame_per_second);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_mode_sort(args.mode_sort);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LibraryDataAnimation::VT_NAME, None)}
  }
  #[inline]
  pub fn frame_per_second(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LibraryDataAnimation::VT_FRAME_PER_SECOND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn count_frame(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LibraryDataAnimation::VT_COUNT_FRAME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn size_canvas_x(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LibraryDataAnimation::VT_SIZE_CANVAS_X, Some(0)).unwrap()}
  }
  #[inline]
  pub fn size_canvas_y(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LibraryDataAnimation::VT_SIZE_CANVAS_Y, Some(0)).unwrap()}
  }
  #[inline]
  pub fn frame_valid_start(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LibraryDataAnimation::VT_FRAME_VALID_START, Some(0)).unwrap()}
  }
  #[inline]
  pub fn frame_valid_end(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LibraryDataAnimation::VT_FRAME_VALID_END, Some(0)).unwrap()}
  }
  #[inline]
  pub fn count_frame_valid(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LibraryDataAnimation::VT_COUNT_FRAME_VALID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn depth_ik(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LibraryDataAnimation::VT_DEPTH_IK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn mode_sort(&self) -> KindModeSort {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KindModeSort>(LibraryDataAnimation::VT_MODE_SORT, Some(KindModeSort::Priority)).unwrap()}
  }
  #[inline]
  pub fn table_label(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Label<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Label>>>>(LibraryDataAnimation::VT_TABLE_LABEL, None)}
  }
  #[inline]
  pub fn table_parts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataAnimationParts<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataAnimationParts>>>>(LibraryDataAnimation::VT_TABLE_PARTS, None)}
  }
}

impl flatbuffers::Verifiable for LibraryDataAnimation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<i32>("frame_per_second", Self::VT_FRAME_PER_SECOND, false)?
     .visit_field::<i32>("count_frame", Self::VT_COUNT_FRAME, false)?
     .visit_field::<i32>("size_canvas_x", Self::VT_SIZE_CANVAS_X, false)?
     .visit_field::<i32>("size_canvas_y", Self::VT_SIZE_CANVAS_Y, false)?
     .visit_field::<i32>("frame_valid_start", Self::VT_FRAME_VALID_START, false)?
     .visit_field::<i32>("frame_valid_end", Self::VT_FRAME_VALID_END, false)?
     .visit_field::<i32>("count_frame_valid", Self::VT_COUNT_FRAME_VALID, false)?
     .visit_field::<i32>("depth_ik", Self::VT_DEPTH_IK, false)?
     .visit_field::<KindModeSort>("mode_sort", Self::VT_MODE_SORT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Label>>>>("table_label", Self::VT_TABLE_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataAnimationParts>>>>("table_parts", Self::VT_TABLE_PARTS, false)?
     .finish();
    Ok(())
  }
}
pub struct LibraryDataAnimationArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub frame_per_second: i32,
    pub count_frame: i32,
    pub size_canvas_x: i32,
    pub size_canvas_y: i32,
    pub frame_valid_start: i32,
    pub frame_valid_end: i32,
    pub count_frame_valid: i32,
    pub depth_ik: i32,
    pub mode_sort: KindModeSort,
    pub table_label: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Label<'a>>>>>,
    pub table_parts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataAnimationParts<'a>>>>>,
}
impl<'a> Default for LibraryDataAnimationArgs<'a> {
  #[inline]
  fn default() -> Self {
    LibraryDataAnimationArgs {
      name: None,
      frame_per_second: 0,
      count_frame: 0,
      size_canvas_x: 0,
      size_canvas_y: 0,
      frame_valid_start: 0,
      frame_valid_end: 0,
      count_frame_valid: 0,
      depth_ik: 0,
      mode_sort: KindModeSort::Priority,
      table_label: None,
      table_parts: None,
    }
  }
}

pub struct LibraryDataAnimationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LibraryDataAnimationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LibraryDataAnimation::VT_NAME, name);
  }
  #[inline]
  pub fn add_frame_per_second(&mut self, frame_per_second: i32) {
    self.fbb_.push_slot::<i32>(LibraryDataAnimation::VT_FRAME_PER_SECOND, frame_per_second, 0);
  }
  #[inline]
  pub fn add_count_frame(&mut self, count_frame: i32) {
    self.fbb_.push_slot::<i32>(LibraryDataAnimation::VT_COUNT_FRAME, count_frame, 0);
  }
  #[inline]
  pub fn add_size_canvas_x(&mut self, size_canvas_x: i32) {
    self.fbb_.push_slot::<i32>(LibraryDataAnimation::VT_SIZE_CANVAS_X, size_canvas_x, 0);
  }
  #[inline]
  pub fn add_size_canvas_y(&mut self, size_canvas_y: i32) {
    self.fbb_.push_slot::<i32>(LibraryDataAnimation::VT_SIZE_CANVAS_Y, size_canvas_y, 0);
  }
  #[inline]
  pub fn add_frame_valid_start(&mut self, frame_valid_start: i32) {
    self.fbb_.push_slot::<i32>(LibraryDataAnimation::VT_FRAME_VALID_START, frame_valid_start, 0);
  }
  #[inline]
  pub fn add_frame_valid_end(&mut self, frame_valid_end: i32) {
    self.fbb_.push_slot::<i32>(LibraryDataAnimation::VT_FRAME_VALID_END, frame_valid_end, 0);
  }
  #[inline]
  pub fn add_count_frame_valid(&mut self, count_frame_valid: i32) {
    self.fbb_.push_slot::<i32>(LibraryDataAnimation::VT_COUNT_FRAME_VALID, count_frame_valid, 0);
  }
  #[inline]
  pub fn add_depth_ik(&mut self, depth_ik: i32) {
    self.fbb_.push_slot::<i32>(LibraryDataAnimation::VT_DEPTH_IK, depth_ik, 0);
  }
  #[inline]
  pub fn add_mode_sort(&mut self, mode_sort: KindModeSort) {
    self.fbb_.push_slot::<KindModeSort>(LibraryDataAnimation::VT_MODE_SORT, mode_sort, KindModeSort::Priority);
  }
  #[inline]
  pub fn add_table_label(&mut self, table_label: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Label<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LibraryDataAnimation::VT_TABLE_LABEL, table_label);
  }
  #[inline]
  pub fn add_table_parts(&mut self, table_parts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataAnimationParts<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LibraryDataAnimation::VT_TABLE_PARTS, table_parts);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LibraryDataAnimationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LibraryDataAnimationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LibraryDataAnimation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LibraryDataAnimation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LibraryDataAnimation");
      ds.field("name", &self.name());
      ds.field("frame_per_second", &self.frame_per_second());
      ds.field("count_frame", &self.count_frame());
      ds.field("size_canvas_x", &self.size_canvas_x());
      ds.field("size_canvas_y", &self.size_canvas_y());
      ds.field("frame_valid_start", &self.frame_valid_start());
      ds.field("frame_valid_end", &self.frame_valid_end());
      ds.field("count_frame_valid", &self.count_frame_valid());
      ds.field("depth_ik", &self.depth_ik());
      ds.field("mode_sort", &self.mode_sort());
      ds.field("table_label", &self.table_label());
      ds.field("table_parts", &self.table_parts());
      ds.finish()
  }
}
pub enum UserDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UserData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UserData<'a> {
  type Inner = UserData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UserData<'a> {
  pub const VT_FLAGS: flatbuffers::VOffsetT = 4;
  pub const VT_NUMBER_INT: flatbuffers::VOffsetT = 6;
  pub const VT_RECTANGLE: flatbuffers::VOffsetT = 8;
  pub const VT_COORDINATE: flatbuffers::VOffsetT = 10;
  pub const VT_TEXT: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UserData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UserDataArgs<'args>
  ) -> flatbuffers::WIPOffset<UserData<'bldr>> {
    let mut builder = UserDataBuilder::new(_fbb);
    if let Some(x) = args.text { builder.add_text(x); }
    if let Some(x) = args.coordinate { builder.add_coordinate(x); }
    if let Some(x) = args.rectangle { builder.add_rectangle(x); }
    builder.add_number_int(args.number_int);
    builder.add_flags(args.flags);
    builder.finish()
  }


  #[inline]
  pub fn flags(&self) -> UserDataFlagBit {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<UserDataFlagBit>(UserData::VT_FLAGS, Some(UserDataFlagBit::CLEAR)).unwrap()}
  }
  #[inline]
  pub fn number_int(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(UserData::VT_NUMBER_INT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rectangle(&self) -> Option<Rect<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Rect>>(UserData::VT_RECTANGLE, None)}
  }
  #[inline]
  pub fn coordinate(&self) -> Option<Vector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Vector2>>(UserData::VT_COORDINATE, None)}
  }
  #[inline]
  pub fn text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UserData::VT_TEXT, None)}
  }
}

impl flatbuffers::Verifiable for UserData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<UserDataFlagBit>("flags", Self::VT_FLAGS, false)?
     .visit_field::<i32>("number_int", Self::VT_NUMBER_INT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Rect>>("rectangle", Self::VT_RECTANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Vector2>>("coordinate", Self::VT_COORDINATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct UserDataArgs<'a> {
    pub flags: UserDataFlagBit,
    pub number_int: i32,
    pub rectangle: Option<flatbuffers::WIPOffset<Rect<'a>>>,
    pub coordinate: Option<flatbuffers::WIPOffset<Vector2<'a>>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for UserDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    UserDataArgs {
      flags: UserDataFlagBit::CLEAR,
      number_int: 0,
      rectangle: None,
      coordinate: None,
      text: None,
    }
  }
}

pub struct UserDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UserDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_flags(&mut self, flags: UserDataFlagBit) {
    self.fbb_.push_slot::<UserDataFlagBit>(UserData::VT_FLAGS, flags, UserDataFlagBit::CLEAR);
  }
  #[inline]
  pub fn add_number_int(&mut self, number_int: i32) {
    self.fbb_.push_slot::<i32>(UserData::VT_NUMBER_INT, number_int, 0);
  }
  #[inline]
  pub fn add_rectangle(&mut self, rectangle: flatbuffers::WIPOffset<Rect<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Rect>>(UserData::VT_RECTANGLE, rectangle);
  }
  #[inline]
  pub fn add_coordinate(&mut self, coordinate: flatbuffers::WIPOffset<Vector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vector2>>(UserData::VT_COORDINATE, coordinate);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UserData::VT_TEXT, text);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UserDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UserDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UserData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UserData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UserData");
      ds.field("flags", &self.flags());
      ds.field("number_int", &self.number_int());
      ds.field("rectangle", &self.rectangle());
      ds.field("coordinate", &self.coordinate());
      ds.field("text", &self.text());
      ds.finish()
  }
}
pub enum DataSetupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataSetup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataSetup<'a> {
  type Inner = DataSetup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataSetup<'a> {
  pub const VT_USER_DATA: flatbuffers::VOffsetT = 4;
  pub const VT_SIGNAL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataSetup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataSetupArgs<'args>
  ) -> flatbuffers::WIPOffset<DataSetup<'bldr>> {
    let mut builder = DataSetupBuilder::new(_fbb);
    if let Some(x) = args.signal { builder.add_signal(x); }
    if let Some(x) = args.user_data { builder.add_user_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn user_data(&self) -> Option<UserData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<UserData>>(DataSetup::VT_USER_DATA, None)}
  }
  #[inline]
  pub fn signal(&self) -> Option<AnimationAttributeSignal<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AnimationAttributeSignal>>(DataSetup::VT_SIGNAL, None)}
  }
}

impl flatbuffers::Verifiable for DataSetup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<UserData>>("user_data", Self::VT_USER_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AnimationAttributeSignal>>("signal", Self::VT_SIGNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct DataSetupArgs<'a> {
    pub user_data: Option<flatbuffers::WIPOffset<UserData<'a>>>,
    pub signal: Option<flatbuffers::WIPOffset<AnimationAttributeSignal<'a>>>,
}
impl<'a> Default for DataSetupArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataSetupArgs {
      user_data: None,
      signal: None,
    }
  }
}

pub struct DataSetupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataSetupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user_data(&mut self, user_data: flatbuffers::WIPOffset<UserData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UserData>>(DataSetup::VT_USER_DATA, user_data);
  }
  #[inline]
  pub fn add_signal(&mut self, signal: flatbuffers::WIPOffset<AnimationAttributeSignal<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AnimationAttributeSignal>>(DataSetup::VT_SIGNAL, signal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataSetupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataSetupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataSetup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataSetup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataSetup");
      ds.field("user_data", &self.user_data());
      ds.field("signal", &self.signal());
      ds.finish()
  }
}
pub enum DataAnimationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataAnimation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataAnimation<'a> {
  type Inner = DataAnimation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataAnimation<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_TABLE_PARTS: flatbuffers::VOffsetT = 8;
  pub const VT_CATALOG_PARTS: flatbuffers::VOffsetT = 10;
  pub const VT_TABLE_ANIMATION: flatbuffers::VOffsetT = 12;
  pub const VT_TABLE_ANIMATION_PARTS_SETUP: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataAnimation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataAnimationArgs<'args>
  ) -> flatbuffers::WIPOffset<DataAnimation<'bldr>> {
    let mut builder = DataAnimationBuilder::new(_fbb);
    if let Some(x) = args.table_animation_parts_setup { builder.add_table_animation_parts_setup(x); }
    if let Some(x) = args.table_animation { builder.add_table_animation(x); }
    if let Some(x) = args.catalog_parts { builder.add_catalog_parts(x); }
    if let Some(x) = args.table_parts { builder.add_table_parts(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_version(args.version);
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DataAnimation::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataAnimation::VT_NAME, None)}
  }
  #[inline]
  pub fn table_parts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataModelParts<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataModelParts>>>>(DataAnimation::VT_TABLE_PARTS, None)}
  }
  #[inline]
  pub fn catalog_parts(&self) -> Option<Catalog<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Catalog>>(DataAnimation::VT_CATALOG_PARTS, None)}
  }
  #[inline]
  pub fn table_animation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LibraryDataAnimation<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LibraryDataAnimation>>>>(DataAnimation::VT_TABLE_ANIMATION, None)}
  }
  #[inline]
  pub fn table_animation_parts_setup(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataSetup<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataSetup>>>>(DataAnimation::VT_TABLE_ANIMATION_PARTS_SETUP, None)}
  }
}

impl flatbuffers::Verifiable for DataAnimation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataModelParts>>>>("table_parts", Self::VT_TABLE_PARTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Catalog>>("catalog_parts", Self::VT_CATALOG_PARTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<LibraryDataAnimation>>>>("table_animation", Self::VT_TABLE_ANIMATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataSetup>>>>("table_animation_parts_setup", Self::VT_TABLE_ANIMATION_PARTS_SETUP, false)?
     .finish();
    Ok(())
  }
}
pub struct DataAnimationArgs<'a> {
    pub version: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub table_parts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataModelParts<'a>>>>>,
    pub catalog_parts: Option<flatbuffers::WIPOffset<Catalog<'a>>>,
    pub table_animation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LibraryDataAnimation<'a>>>>>,
    pub table_animation_parts_setup: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataSetup<'a>>>>>,
}
impl<'a> Default for DataAnimationArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataAnimationArgs {
      version: 0,
      name: None,
      table_parts: None,
      catalog_parts: None,
      table_animation: None,
      table_animation_parts_setup: None,
    }
  }
}

pub struct DataAnimationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataAnimationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(DataAnimation::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataAnimation::VT_NAME, name);
  }
  #[inline]
  pub fn add_table_parts(&mut self, table_parts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataModelParts<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataAnimation::VT_TABLE_PARTS, table_parts);
  }
  #[inline]
  pub fn add_catalog_parts(&mut self, catalog_parts: flatbuffers::WIPOffset<Catalog<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Catalog>>(DataAnimation::VT_CATALOG_PARTS, catalog_parts);
  }
  #[inline]
  pub fn add_table_animation(&mut self, table_animation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<LibraryDataAnimation<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataAnimation::VT_TABLE_ANIMATION, table_animation);
  }
  #[inline]
  pub fn add_table_animation_parts_setup(&mut self, table_animation_parts_setup: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataSetup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataAnimation::VT_TABLE_ANIMATION_PARTS_SETUP, table_animation_parts_setup);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataAnimationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataAnimationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataAnimation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataAnimation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataAnimation");
      ds.field("version", &self.version());
      ds.field("name", &self.name());
      ds.field("table_parts", &self.table_parts());
      ds.field("catalog_parts", &self.catalog_parts());
      ds.field("table_animation", &self.table_animation());
      ds.field("table_animation_parts_setup", &self.table_animation_parts_setup());
      ds.finish()
  }
}
pub enum DataEffectPartsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataEffectParts<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataEffectParts<'a> {
  type Inner = DataEffectParts<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataEffectParts<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_ID_PARENT: flatbuffers::VOffsetT = 8;
  pub const VT_TABLE_ID_CHILD: flatbuffers::VOffsetT = 10;
  pub const VT_FEATURE: flatbuffers::VOffsetT = 12;
  pub const VT_INDEX_EMITTER: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataEffectParts { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataEffectPartsArgs<'args>
  ) -> flatbuffers::WIPOffset<DataEffectParts<'bldr>> {
    let mut builder = DataEffectPartsBuilder::new(_fbb);
    if let Some(x) = args.table_id_child { builder.add_table_id_child(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_index_emitter(args.index_emitter);
    builder.add_feature(args.feature);
    builder.add_id_parent(args.id_parent);
    builder.add_id(args.id);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataEffectParts::VT_NAME, None)}
  }
  #[inline]
  pub fn id(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DataEffectParts::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn id_parent(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DataEffectParts::VT_ID_PARENT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn table_id_child(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(DataEffectParts::VT_TABLE_ID_CHILD, None)}
  }
  #[inline]
  pub fn feature(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DataEffectParts::VT_FEATURE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn index_emitter(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DataEffectParts::VT_INDEX_EMITTER, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DataEffectParts<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u16>("id", Self::VT_ID, false)?
     .visit_field::<u16>("id_parent", Self::VT_ID_PARENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("table_id_child", Self::VT_TABLE_ID_CHILD, false)?
     .visit_field::<u16>("feature", Self::VT_FEATURE, false)?
     .visit_field::<u16>("index_emitter", Self::VT_INDEX_EMITTER, false)?
     .finish();
    Ok(())
  }
}
pub struct DataEffectPartsArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: u16,
    pub id_parent: u16,
    pub table_id_child: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub feature: u16,
    pub index_emitter: u16,
}
impl<'a> Default for DataEffectPartsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataEffectPartsArgs {
      name: None,
      id: 0,
      id_parent: 0,
      table_id_child: None,
      feature: 0,
      index_emitter: 0,
    }
  }
}

pub struct DataEffectPartsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataEffectPartsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataEffectParts::VT_NAME, name);
  }
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(DataEffectParts::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_id_parent(&mut self, id_parent: u16) {
    self.fbb_.push_slot::<u16>(DataEffectParts::VT_ID_PARENT, id_parent, 0);
  }
  #[inline]
  pub fn add_table_id_child(&mut self, table_id_child: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataEffectParts::VT_TABLE_ID_CHILD, table_id_child);
  }
  #[inline]
  pub fn add_feature(&mut self, feature: u16) {
    self.fbb_.push_slot::<u16>(DataEffectParts::VT_FEATURE, feature, 0);
  }
  #[inline]
  pub fn add_index_emitter(&mut self, index_emitter: u16) {
    self.fbb_.push_slot::<u16>(DataEffectParts::VT_INDEX_EMITTER, index_emitter, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataEffectPartsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataEffectPartsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataEffectParts<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataEffectParts<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataEffectParts");
      ds.field("name", &self.name());
      ds.field("id", &self.id());
      ds.field("id_parent", &self.id_parent());
      ds.field("table_id_child", &self.table_id_child());
      ds.field("feature", &self.feature());
      ds.field("index_emitter", &self.index_emitter());
      ds.finish()
  }
}
pub enum DataEffectEmitterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataEffectEmitter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataEffectEmitter<'a> {
  type Inner = DataEffectEmitter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataEffectEmitter<'a> {
  pub const VT_FLAG_DATA: flatbuffers::VOffsetT = 4;
  pub const VT_OPERATION_BLEND_TARGET: flatbuffers::VOffsetT = 6;
  pub const VT_INDEX_CELL_MAP: flatbuffers::VOffsetT = 8;
  pub const VT_INDEX_CELL: flatbuffers::VOffsetT = 10;
  pub const VT_ANGLE: flatbuffers::VOffsetT = 12;
  pub const VT_GRAVITY_DIRECTIONAL: flatbuffers::VOffsetT = 14;
  pub const VT_GRAVITY_POINT_POSITION: flatbuffers::VOffsetT = 16;
  pub const VT_GRAVITY_POINT_POWER: flatbuffers::VOffsetT = 18;
  pub const VT_POSITION: flatbuffers::VOffsetT = 20;
  pub const VT_ROTATION: flatbuffers::VOffsetT = 22;
  pub const VT_ROTATION_FLUCTUATION: flatbuffers::VOffsetT = 24;
  pub const VT_ROTATION_FLUCTUATION_RATE: flatbuffers::VOffsetT = 26;
  pub const VT_ROTATION_FLUCTUATION_RATE_TIME: flatbuffers::VOffsetT = 28;
  pub const VT_RATE_TANGENTIAL_ACCELERATION: flatbuffers::VOffsetT = 30;
  pub const VT_SCALE_START: flatbuffers::VOffsetT = 32;
  pub const VT_SCALE_RATE_START: flatbuffers::VOffsetT = 34;
  pub const VT_SCALE_END: flatbuffers::VOffsetT = 36;
  pub const VT_SCALE_RATE_END: flatbuffers::VOffsetT = 38;
  pub const VT_DELAY: flatbuffers::VOffsetT = 40;
  pub const VT_COLOR_VERTEX: flatbuffers::VOffsetT = 42;
  pub const VT_COLOR_VERTEX_FLUCTUATION: flatbuffers::VOffsetT = 44;
  pub const VT_ALPHA_FADE_START: flatbuffers::VOffsetT = 46;
  pub const VT_ALPHA_FADE_END: flatbuffers::VOffsetT = 48;
  pub const VT_SPEED: flatbuffers::VOffsetT = 50;
  pub const VT_SPEED_FLUCTUATION: flatbuffers::VOffsetT = 52;
  pub const VT_TURN_DIRECTION_FLUCTUATION: flatbuffers::VOffsetT = 54;
  pub const VT_SEED_RANDOM: flatbuffers::VOffsetT = 56;
  pub const VT_DURATION_EMITTER: flatbuffers::VOffsetT = 58;
  pub const VT_INTERVAL: flatbuffers::VOffsetT = 60;
  pub const VT_DURATION_PARTICLE: flatbuffers::VOffsetT = 62;
  pub const VT_COUNT_PARTICLE_MAX: flatbuffers::VOffsetT = 64;
  pub const VT_COUNT_PARTICLE_EMIT: flatbuffers::VOffsetT = 66;
  pub const VT_COUNT_PARTS_MAXIMUM: flatbuffers::VOffsetT = 68;
  pub const VT_TABLE_PATTERN_EMIT: flatbuffers::VOffsetT = 70;
  pub const VT_TABLE_PATTERN_OFFSET: flatbuffers::VOffsetT = 72;
  pub const VT_TABLE_SEED_PARTICLE: flatbuffers::VOffsetT = 74;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataEffectEmitter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataEffectEmitterArgs<'args>
  ) -> flatbuffers::WIPOffset<DataEffectEmitter<'bldr>> {
    let mut builder = DataEffectEmitterBuilder::new(_fbb);
    builder.add_seed_random(args.seed_random);
    if let Some(x) = args.table_seed_particle { builder.add_table_seed_particle(x); }
    if let Some(x) = args.table_pattern_offset { builder.add_table_pattern_offset(x); }
    if let Some(x) = args.table_pattern_emit { builder.add_table_pattern_emit(x); }
    builder.add_count_parts_maximum(args.count_parts_maximum);
    builder.add_count_particle_emit(args.count_particle_emit);
    builder.add_count_particle_max(args.count_particle_max);
    if let Some(x) = args.duration_particle { builder.add_duration_particle(x); }
    builder.add_interval(args.interval);
    builder.add_duration_emitter(args.duration_emitter);
    builder.add_turn_direction_fluctuation(args.turn_direction_fluctuation);
    if let Some(x) = args.speed_fluctuation { builder.add_speed_fluctuation(x); }
    if let Some(x) = args.speed { builder.add_speed(x); }
    builder.add_alpha_fade_end(args.alpha_fade_end);
    builder.add_alpha_fade_start(args.alpha_fade_start);
    if let Some(x) = args.color_vertex_fluctuation { builder.add_color_vertex_fluctuation(x); }
    if let Some(x) = args.color_vertex { builder.add_color_vertex(x); }
    builder.add_delay(args.delay);
    if let Some(x) = args.scale_rate_end { builder.add_scale_rate_end(x); }
    if let Some(x) = args.scale_end { builder.add_scale_end(x); }
    if let Some(x) = args.scale_rate_start { builder.add_scale_rate_start(x); }
    if let Some(x) = args.scale_start { builder.add_scale_start(x); }
    if let Some(x) = args.rate_tangential_acceleration { builder.add_rate_tangential_acceleration(x); }
    builder.add_rotation_fluctuation_rate_time(args.rotation_fluctuation_rate_time);
    builder.add_rotation_fluctuation_rate(args.rotation_fluctuation_rate);
    if let Some(x) = args.rotation_fluctuation { builder.add_rotation_fluctuation(x); }
    if let Some(x) = args.rotation { builder.add_rotation(x); }
    if let Some(x) = args.position { builder.add_position(x); }
    builder.add_gravity_point_power(args.gravity_point_power);
    if let Some(x) = args.gravity_point_position { builder.add_gravity_point_position(x); }
    if let Some(x) = args.gravity_directional { builder.add_gravity_directional(x); }
    if let Some(x) = args.angle { builder.add_angle(x); }
    builder.add_operation_blend_target(args.operation_blend_target);
    builder.add_flag_data(args.flag_data);
    builder.add_index_cell(args.index_cell);
    builder.add_index_cell_map(args.index_cell_map);
    builder.finish()
  }


  #[inline]
  pub fn flag_data(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DataEffectEmitter::VT_FLAG_DATA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn operation_blend_target(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DataEffectEmitter::VT_OPERATION_BLEND_TARGET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn index_cell_map(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DataEffectEmitter::VT_INDEX_CELL_MAP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn index_cell(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DataEffectEmitter::VT_INDEX_CELL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn angle(&self) -> Option<RangeFloat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeFloat>>(DataEffectEmitter::VT_ANGLE, None)}
  }
  #[inline]
  pub fn gravity_directional(&self) -> Option<Vector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Vector2>>(DataEffectEmitter::VT_GRAVITY_DIRECTIONAL, None)}
  }
  #[inline]
  pub fn gravity_point_position(&self) -> Option<Vector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Vector2>>(DataEffectEmitter::VT_GRAVITY_POINT_POSITION, None)}
  }
  #[inline]
  pub fn gravity_point_power(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DataEffectEmitter::VT_GRAVITY_POINT_POWER, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn position(&self) -> Option<RangeVector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeVector2>>(DataEffectEmitter::VT_POSITION, None)}
  }
  #[inline]
  pub fn rotation(&self) -> Option<RangeFloat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeFloat>>(DataEffectEmitter::VT_ROTATION, None)}
  }
  #[inline]
  pub fn rotation_fluctuation(&self) -> Option<RangeFloat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeFloat>>(DataEffectEmitter::VT_ROTATION_FLUCTUATION, None)}
  }
  #[inline]
  pub fn rotation_fluctuation_rate(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DataEffectEmitter::VT_ROTATION_FLUCTUATION_RATE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn rotation_fluctuation_rate_time(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DataEffectEmitter::VT_ROTATION_FLUCTUATION_RATE_TIME, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn rate_tangential_acceleration(&self) -> Option<RangeFloat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeFloat>>(DataEffectEmitter::VT_RATE_TANGENTIAL_ACCELERATION, None)}
  }
  #[inline]
  pub fn scale_start(&self) -> Option<RangeVector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeVector2>>(DataEffectEmitter::VT_SCALE_START, None)}
  }
  #[inline]
  pub fn scale_rate_start(&self) -> Option<RangeFloat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeFloat>>(DataEffectEmitter::VT_SCALE_RATE_START, None)}
  }
  #[inline]
  pub fn scale_end(&self) -> Option<RangeVector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeVector2>>(DataEffectEmitter::VT_SCALE_END, None)}
  }
  #[inline]
  pub fn scale_rate_end(&self) -> Option<RangeFloat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeFloat>>(DataEffectEmitter::VT_SCALE_RATE_END, None)}
  }
  #[inline]
  pub fn delay(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataEffectEmitter::VT_DELAY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn color_vertex(&self) -> Option<RangeColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeColor>>(DataEffectEmitter::VT_COLOR_VERTEX, None)}
  }
  #[inline]
  pub fn color_vertex_fluctuation(&self) -> Option<RangeColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeColor>>(DataEffectEmitter::VT_COLOR_VERTEX_FLUCTUATION, None)}
  }
  #[inline]
  pub fn alpha_fade_start(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DataEffectEmitter::VT_ALPHA_FADE_START, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn alpha_fade_end(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DataEffectEmitter::VT_ALPHA_FADE_END, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn speed(&self) -> Option<RangeFloat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeFloat>>(DataEffectEmitter::VT_SPEED, None)}
  }
  #[inline]
  pub fn speed_fluctuation(&self) -> Option<RangeFloat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeFloat>>(DataEffectEmitter::VT_SPEED_FLUCTUATION, None)}
  }
  #[inline]
  pub fn turn_direction_fluctuation(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DataEffectEmitter::VT_TURN_DIRECTION_FLUCTUATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn seed_random(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(DataEffectEmitter::VT_SEED_RANDOM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn duration_emitter(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataEffectEmitter::VT_DURATION_EMITTER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn interval(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataEffectEmitter::VT_INTERVAL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn duration_particle(&self) -> Option<RangeFloat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeFloat>>(DataEffectEmitter::VT_DURATION_PARTICLE, None)}
  }
  #[inline]
  pub fn count_particle_max(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataEffectEmitter::VT_COUNT_PARTICLE_MAX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn count_particle_emit(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataEffectEmitter::VT_COUNT_PARTICLE_EMIT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn count_parts_maximum(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataEffectEmitter::VT_COUNT_PARTS_MAXIMUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn table_pattern_emit(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PatternEmit<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PatternEmit>>>>(DataEffectEmitter::VT_TABLE_PATTERN_EMIT, None)}
  }
  #[inline]
  pub fn table_pattern_offset(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(DataEffectEmitter::VT_TABLE_PATTERN_OFFSET, None)}
  }
  #[inline]
  pub fn table_seed_particle(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(DataEffectEmitter::VT_TABLE_SEED_PARTICLE, None)}
  }
}

impl flatbuffers::Verifiable for DataEffectEmitter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("flag_data", Self::VT_FLAG_DATA, false)?
     .visit_field::<u32>("operation_blend_target", Self::VT_OPERATION_BLEND_TARGET, false)?
     .visit_field::<u16>("index_cell_map", Self::VT_INDEX_CELL_MAP, false)?
     .visit_field::<u16>("index_cell", Self::VT_INDEX_CELL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeFloat>>("angle", Self::VT_ANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Vector2>>("gravity_directional", Self::VT_GRAVITY_DIRECTIONAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Vector2>>("gravity_point_position", Self::VT_GRAVITY_POINT_POSITION, false)?
     .visit_field::<f32>("gravity_point_power", Self::VT_GRAVITY_POINT_POWER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeVector2>>("position", Self::VT_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeFloat>>("rotation", Self::VT_ROTATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeFloat>>("rotation_fluctuation", Self::VT_ROTATION_FLUCTUATION, false)?
     .visit_field::<f32>("rotation_fluctuation_rate", Self::VT_ROTATION_FLUCTUATION_RATE, false)?
     .visit_field::<f32>("rotation_fluctuation_rate_time", Self::VT_ROTATION_FLUCTUATION_RATE_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeFloat>>("rate_tangential_acceleration", Self::VT_RATE_TANGENTIAL_ACCELERATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeVector2>>("scale_start", Self::VT_SCALE_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeFloat>>("scale_rate_start", Self::VT_SCALE_RATE_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeVector2>>("scale_end", Self::VT_SCALE_END, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeFloat>>("scale_rate_end", Self::VT_SCALE_RATE_END, false)?
     .visit_field::<i32>("delay", Self::VT_DELAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeColor>>("color_vertex", Self::VT_COLOR_VERTEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeColor>>("color_vertex_fluctuation", Self::VT_COLOR_VERTEX_FLUCTUATION, false)?
     .visit_field::<f32>("alpha_fade_start", Self::VT_ALPHA_FADE_START, false)?
     .visit_field::<f32>("alpha_fade_end", Self::VT_ALPHA_FADE_END, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeFloat>>("speed", Self::VT_SPEED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeFloat>>("speed_fluctuation", Self::VT_SPEED_FLUCTUATION, false)?
     .visit_field::<f32>("turn_direction_fluctuation", Self::VT_TURN_DIRECTION_FLUCTUATION, false)?
     .visit_field::<i64>("seed_random", Self::VT_SEED_RANDOM, false)?
     .visit_field::<i32>("duration_emitter", Self::VT_DURATION_EMITTER, false)?
     .visit_field::<i32>("interval", Self::VT_INTERVAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeFloat>>("duration_particle", Self::VT_DURATION_PARTICLE, false)?
     .visit_field::<i32>("count_particle_max", Self::VT_COUNT_PARTICLE_MAX, false)?
     .visit_field::<i32>("count_particle_emit", Self::VT_COUNT_PARTICLE_EMIT, false)?
     .visit_field::<i32>("count_parts_maximum", Self::VT_COUNT_PARTS_MAXIMUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PatternEmit>>>>("table_pattern_emit", Self::VT_TABLE_PATTERN_EMIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("table_pattern_offset", Self::VT_TABLE_PATTERN_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("table_seed_particle", Self::VT_TABLE_SEED_PARTICLE, false)?
     .finish();
    Ok(())
  }
}
pub struct DataEffectEmitterArgs<'a> {
    pub flag_data: u32,
    pub operation_blend_target: u32,
    pub index_cell_map: u16,
    pub index_cell: u16,
    pub angle: Option<flatbuffers::WIPOffset<RangeFloat<'a>>>,
    pub gravity_directional: Option<flatbuffers::WIPOffset<Vector2<'a>>>,
    pub gravity_point_position: Option<flatbuffers::WIPOffset<Vector2<'a>>>,
    pub gravity_point_power: f32,
    pub position: Option<flatbuffers::WIPOffset<RangeVector2<'a>>>,
    pub rotation: Option<flatbuffers::WIPOffset<RangeFloat<'a>>>,
    pub rotation_fluctuation: Option<flatbuffers::WIPOffset<RangeFloat<'a>>>,
    pub rotation_fluctuation_rate: f32,
    pub rotation_fluctuation_rate_time: f32,
    pub rate_tangential_acceleration: Option<flatbuffers::WIPOffset<RangeFloat<'a>>>,
    pub scale_start: Option<flatbuffers::WIPOffset<RangeVector2<'a>>>,
    pub scale_rate_start: Option<flatbuffers::WIPOffset<RangeFloat<'a>>>,
    pub scale_end: Option<flatbuffers::WIPOffset<RangeVector2<'a>>>,
    pub scale_rate_end: Option<flatbuffers::WIPOffset<RangeFloat<'a>>>,
    pub delay: i32,
    pub color_vertex: Option<flatbuffers::WIPOffset<RangeColor<'a>>>,
    pub color_vertex_fluctuation: Option<flatbuffers::WIPOffset<RangeColor<'a>>>,
    pub alpha_fade_start: f32,
    pub alpha_fade_end: f32,
    pub speed: Option<flatbuffers::WIPOffset<RangeFloat<'a>>>,
    pub speed_fluctuation: Option<flatbuffers::WIPOffset<RangeFloat<'a>>>,
    pub turn_direction_fluctuation: f32,
    pub seed_random: i64,
    pub duration_emitter: i32,
    pub interval: i32,
    pub duration_particle: Option<flatbuffers::WIPOffset<RangeFloat<'a>>>,
    pub count_particle_max: i32,
    pub count_particle_emit: i32,
    pub count_parts_maximum: i32,
    pub table_pattern_emit: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PatternEmit<'a>>>>>,
    pub table_pattern_offset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub table_seed_particle: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
}
impl<'a> Default for DataEffectEmitterArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataEffectEmitterArgs {
      flag_data: 0,
      operation_blend_target: 0,
      index_cell_map: 0,
      index_cell: 0,
      angle: None,
      gravity_directional: None,
      gravity_point_position: None,
      gravity_point_power: 0.0,
      position: None,
      rotation: None,
      rotation_fluctuation: None,
      rotation_fluctuation_rate: 0.0,
      rotation_fluctuation_rate_time: 0.0,
      rate_tangential_acceleration: None,
      scale_start: None,
      scale_rate_start: None,
      scale_end: None,
      scale_rate_end: None,
      delay: 0,
      color_vertex: None,
      color_vertex_fluctuation: None,
      alpha_fade_start: 0.0,
      alpha_fade_end: 0.0,
      speed: None,
      speed_fluctuation: None,
      turn_direction_fluctuation: 0.0,
      seed_random: 0,
      duration_emitter: 0,
      interval: 0,
      duration_particle: None,
      count_particle_max: 0,
      count_particle_emit: 0,
      count_parts_maximum: 0,
      table_pattern_emit: None,
      table_pattern_offset: None,
      table_seed_particle: None,
    }
  }
}

pub struct DataEffectEmitterBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataEffectEmitterBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_flag_data(&mut self, flag_data: u32) {
    self.fbb_.push_slot::<u32>(DataEffectEmitter::VT_FLAG_DATA, flag_data, 0);
  }
  #[inline]
  pub fn add_operation_blend_target(&mut self, operation_blend_target: u32) {
    self.fbb_.push_slot::<u32>(DataEffectEmitter::VT_OPERATION_BLEND_TARGET, operation_blend_target, 0);
  }
  #[inline]
  pub fn add_index_cell_map(&mut self, index_cell_map: u16) {
    self.fbb_.push_slot::<u16>(DataEffectEmitter::VT_INDEX_CELL_MAP, index_cell_map, 0);
  }
  #[inline]
  pub fn add_index_cell(&mut self, index_cell: u16) {
    self.fbb_.push_slot::<u16>(DataEffectEmitter::VT_INDEX_CELL, index_cell, 0);
  }
  #[inline]
  pub fn add_angle(&mut self, angle: flatbuffers::WIPOffset<RangeFloat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeFloat>>(DataEffectEmitter::VT_ANGLE, angle);
  }
  #[inline]
  pub fn add_gravity_directional(&mut self, gravity_directional: flatbuffers::WIPOffset<Vector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vector2>>(DataEffectEmitter::VT_GRAVITY_DIRECTIONAL, gravity_directional);
  }
  #[inline]
  pub fn add_gravity_point_position(&mut self, gravity_point_position: flatbuffers::WIPOffset<Vector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vector2>>(DataEffectEmitter::VT_GRAVITY_POINT_POSITION, gravity_point_position);
  }
  #[inline]
  pub fn add_gravity_point_power(&mut self, gravity_point_power: f32) {
    self.fbb_.push_slot::<f32>(DataEffectEmitter::VT_GRAVITY_POINT_POWER, gravity_point_power, 0.0);
  }
  #[inline]
  pub fn add_position(&mut self, position: flatbuffers::WIPOffset<RangeVector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeVector2>>(DataEffectEmitter::VT_POSITION, position);
  }
  #[inline]
  pub fn add_rotation(&mut self, rotation: flatbuffers::WIPOffset<RangeFloat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeFloat>>(DataEffectEmitter::VT_ROTATION, rotation);
  }
  #[inline]
  pub fn add_rotation_fluctuation(&mut self, rotation_fluctuation: flatbuffers::WIPOffset<RangeFloat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeFloat>>(DataEffectEmitter::VT_ROTATION_FLUCTUATION, rotation_fluctuation);
  }
  #[inline]
  pub fn add_rotation_fluctuation_rate(&mut self, rotation_fluctuation_rate: f32) {
    self.fbb_.push_slot::<f32>(DataEffectEmitter::VT_ROTATION_FLUCTUATION_RATE, rotation_fluctuation_rate, 0.0);
  }
  #[inline]
  pub fn add_rotation_fluctuation_rate_time(&mut self, rotation_fluctuation_rate_time: f32) {
    self.fbb_.push_slot::<f32>(DataEffectEmitter::VT_ROTATION_FLUCTUATION_RATE_TIME, rotation_fluctuation_rate_time, 0.0);
  }
  #[inline]
  pub fn add_rate_tangential_acceleration(&mut self, rate_tangential_acceleration: flatbuffers::WIPOffset<RangeFloat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeFloat>>(DataEffectEmitter::VT_RATE_TANGENTIAL_ACCELERATION, rate_tangential_acceleration);
  }
  #[inline]
  pub fn add_scale_start(&mut self, scale_start: flatbuffers::WIPOffset<RangeVector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeVector2>>(DataEffectEmitter::VT_SCALE_START, scale_start);
  }
  #[inline]
  pub fn add_scale_rate_start(&mut self, scale_rate_start: flatbuffers::WIPOffset<RangeFloat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeFloat>>(DataEffectEmitter::VT_SCALE_RATE_START, scale_rate_start);
  }
  #[inline]
  pub fn add_scale_end(&mut self, scale_end: flatbuffers::WIPOffset<RangeVector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeVector2>>(DataEffectEmitter::VT_SCALE_END, scale_end);
  }
  #[inline]
  pub fn add_scale_rate_end(&mut self, scale_rate_end: flatbuffers::WIPOffset<RangeFloat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeFloat>>(DataEffectEmitter::VT_SCALE_RATE_END, scale_rate_end);
  }
  #[inline]
  pub fn add_delay(&mut self, delay: i32) {
    self.fbb_.push_slot::<i32>(DataEffectEmitter::VT_DELAY, delay, 0);
  }
  #[inline]
  pub fn add_color_vertex(&mut self, color_vertex: flatbuffers::WIPOffset<RangeColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeColor>>(DataEffectEmitter::VT_COLOR_VERTEX, color_vertex);
  }
  #[inline]
  pub fn add_color_vertex_fluctuation(&mut self, color_vertex_fluctuation: flatbuffers::WIPOffset<RangeColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeColor>>(DataEffectEmitter::VT_COLOR_VERTEX_FLUCTUATION, color_vertex_fluctuation);
  }
  #[inline]
  pub fn add_alpha_fade_start(&mut self, alpha_fade_start: f32) {
    self.fbb_.push_slot::<f32>(DataEffectEmitter::VT_ALPHA_FADE_START, alpha_fade_start, 0.0);
  }
  #[inline]
  pub fn add_alpha_fade_end(&mut self, alpha_fade_end: f32) {
    self.fbb_.push_slot::<f32>(DataEffectEmitter::VT_ALPHA_FADE_END, alpha_fade_end, 0.0);
  }
  #[inline]
  pub fn add_speed(&mut self, speed: flatbuffers::WIPOffset<RangeFloat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeFloat>>(DataEffectEmitter::VT_SPEED, speed);
  }
  #[inline]
  pub fn add_speed_fluctuation(&mut self, speed_fluctuation: flatbuffers::WIPOffset<RangeFloat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeFloat>>(DataEffectEmitter::VT_SPEED_FLUCTUATION, speed_fluctuation);
  }
  #[inline]
  pub fn add_turn_direction_fluctuation(&mut self, turn_direction_fluctuation: f32) {
    self.fbb_.push_slot::<f32>(DataEffectEmitter::VT_TURN_DIRECTION_FLUCTUATION, turn_direction_fluctuation, 0.0);
  }
  #[inline]
  pub fn add_seed_random(&mut self, seed_random: i64) {
    self.fbb_.push_slot::<i64>(DataEffectEmitter::VT_SEED_RANDOM, seed_random, 0);
  }
  #[inline]
  pub fn add_duration_emitter(&mut self, duration_emitter: i32) {
    self.fbb_.push_slot::<i32>(DataEffectEmitter::VT_DURATION_EMITTER, duration_emitter, 0);
  }
  #[inline]
  pub fn add_interval(&mut self, interval: i32) {
    self.fbb_.push_slot::<i32>(DataEffectEmitter::VT_INTERVAL, interval, 0);
  }
  #[inline]
  pub fn add_duration_particle(&mut self, duration_particle: flatbuffers::WIPOffset<RangeFloat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeFloat>>(DataEffectEmitter::VT_DURATION_PARTICLE, duration_particle);
  }
  #[inline]
  pub fn add_count_particle_max(&mut self, count_particle_max: i32) {
    self.fbb_.push_slot::<i32>(DataEffectEmitter::VT_COUNT_PARTICLE_MAX, count_particle_max, 0);
  }
  #[inline]
  pub fn add_count_particle_emit(&mut self, count_particle_emit: i32) {
    self.fbb_.push_slot::<i32>(DataEffectEmitter::VT_COUNT_PARTICLE_EMIT, count_particle_emit, 0);
  }
  #[inline]
  pub fn add_count_parts_maximum(&mut self, count_parts_maximum: i32) {
    self.fbb_.push_slot::<i32>(DataEffectEmitter::VT_COUNT_PARTS_MAXIMUM, count_parts_maximum, 0);
  }
  #[inline]
  pub fn add_table_pattern_emit(&mut self, table_pattern_emit: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PatternEmit<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataEffectEmitter::VT_TABLE_PATTERN_EMIT, table_pattern_emit);
  }
  #[inline]
  pub fn add_table_pattern_offset(&mut self, table_pattern_offset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataEffectEmitter::VT_TABLE_PATTERN_OFFSET, table_pattern_offset);
  }
  #[inline]
  pub fn add_table_seed_particle(&mut self, table_seed_particle: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataEffectEmitter::VT_TABLE_SEED_PARTICLE, table_seed_particle);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataEffectEmitterBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataEffectEmitterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataEffectEmitter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataEffectEmitter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataEffectEmitter");
      ds.field("flag_data", &self.flag_data());
      ds.field("operation_blend_target", &self.operation_blend_target());
      ds.field("index_cell_map", &self.index_cell_map());
      ds.field("index_cell", &self.index_cell());
      ds.field("angle", &self.angle());
      ds.field("gravity_directional", &self.gravity_directional());
      ds.field("gravity_point_position", &self.gravity_point_position());
      ds.field("gravity_point_power", &self.gravity_point_power());
      ds.field("position", &self.position());
      ds.field("rotation", &self.rotation());
      ds.field("rotation_fluctuation", &self.rotation_fluctuation());
      ds.field("rotation_fluctuation_rate", &self.rotation_fluctuation_rate());
      ds.field("rotation_fluctuation_rate_time", &self.rotation_fluctuation_rate_time());
      ds.field("rate_tangential_acceleration", &self.rate_tangential_acceleration());
      ds.field("scale_start", &self.scale_start());
      ds.field("scale_rate_start", &self.scale_rate_start());
      ds.field("scale_end", &self.scale_end());
      ds.field("scale_rate_end", &self.scale_rate_end());
      ds.field("delay", &self.delay());
      ds.field("color_vertex", &self.color_vertex());
      ds.field("color_vertex_fluctuation", &self.color_vertex_fluctuation());
      ds.field("alpha_fade_start", &self.alpha_fade_start());
      ds.field("alpha_fade_end", &self.alpha_fade_end());
      ds.field("speed", &self.speed());
      ds.field("speed_fluctuation", &self.speed_fluctuation());
      ds.field("turn_direction_fluctuation", &self.turn_direction_fluctuation());
      ds.field("seed_random", &self.seed_random());
      ds.field("duration_emitter", &self.duration_emitter());
      ds.field("interval", &self.interval());
      ds.field("duration_particle", &self.duration_particle());
      ds.field("count_particle_max", &self.count_particle_max());
      ds.field("count_particle_emit", &self.count_particle_emit());
      ds.field("count_parts_maximum", &self.count_parts_maximum());
      ds.field("table_pattern_emit", &self.table_pattern_emit());
      ds.field("table_pattern_offset", &self.table_pattern_offset());
      ds.field("table_seed_particle", &self.table_seed_particle());
      ds.finish()
  }
}
pub enum DataEffectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataEffect<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataEffect<'a> {
  type Inner = DataEffect<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataEffect<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_FLAG_DATA: flatbuffers::VOffsetT = 8;
  pub const VT_SEED_RANDOM: flatbuffers::VOffsetT = 10;
  pub const VT_VERSION_RENDERER: flatbuffers::VOffsetT = 12;
  pub const VT_COUNT_MAX_PARTICLE: flatbuffers::VOffsetT = 14;
  pub const VT_COUNT_FRAME_PER_SECOND: flatbuffers::VOffsetT = 16;
  pub const VT_SCALE_LAYOUT: flatbuffers::VOffsetT = 18;
  pub const VT_TABLE_PARTS: flatbuffers::VOffsetT = 20;
  pub const VT_TABLE_EMITTER: flatbuffers::VOffsetT = 22;
  pub const VT_TABLE_INDEX_EMITTER_ORDER_DRAW: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataEffect { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataEffectArgs<'args>
  ) -> flatbuffers::WIPOffset<DataEffect<'bldr>> {
    let mut builder = DataEffectBuilder::new(_fbb);
    if let Some(x) = args.table_index_emitter_order_draw { builder.add_table_index_emitter_order_draw(x); }
    if let Some(x) = args.table_emitter { builder.add_table_emitter(x); }
    if let Some(x) = args.table_parts { builder.add_table_parts(x); }
    if let Some(x) = args.scale_layout { builder.add_scale_layout(x); }
    builder.add_count_frame_per_second(args.count_frame_per_second);
    builder.add_count_max_particle(args.count_max_particle);
    builder.add_version_renderer(args.version_renderer);
    builder.add_seed_random(args.seed_random);
    builder.add_flag_data(args.flag_data);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_version(args.version);
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DataEffect::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataEffect::VT_NAME, None)}
  }
  #[inline]
  pub fn flag_data(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataEffect::VT_FLAG_DATA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn seed_random(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataEffect::VT_SEED_RANDOM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn version_renderer(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataEffect::VT_VERSION_RENDERER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn count_max_particle(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataEffect::VT_COUNT_MAX_PARTICLE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn count_frame_per_second(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataEffect::VT_COUNT_FRAME_PER_SECOND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn scale_layout(&self) -> Option<Vector2<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Vector2>>(DataEffect::VT_SCALE_LAYOUT, None)}
  }
  #[inline]
  pub fn table_parts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataEffectParts<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataEffectParts>>>>(DataEffect::VT_TABLE_PARTS, None)}
  }
  #[inline]
  pub fn table_emitter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataEffectEmitter<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataEffectEmitter>>>>(DataEffect::VT_TABLE_EMITTER, None)}
  }
  #[inline]
  pub fn table_index_emitter_order_draw(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(DataEffect::VT_TABLE_INDEX_EMITTER_ORDER_DRAW, None)}
  }
}

impl flatbuffers::Verifiable for DataEffect<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<i32>("flag_data", Self::VT_FLAG_DATA, false)?
     .visit_field::<i32>("seed_random", Self::VT_SEED_RANDOM, false)?
     .visit_field::<i32>("version_renderer", Self::VT_VERSION_RENDERER, false)?
     .visit_field::<i32>("count_max_particle", Self::VT_COUNT_MAX_PARTICLE, false)?
     .visit_field::<i32>("count_frame_per_second", Self::VT_COUNT_FRAME_PER_SECOND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Vector2>>("scale_layout", Self::VT_SCALE_LAYOUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataEffectParts>>>>("table_parts", Self::VT_TABLE_PARTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataEffectEmitter>>>>("table_emitter", Self::VT_TABLE_EMITTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("table_index_emitter_order_draw", Self::VT_TABLE_INDEX_EMITTER_ORDER_DRAW, false)?
     .finish();
    Ok(())
  }
}
pub struct DataEffectArgs<'a> {
    pub version: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub flag_data: i32,
    pub seed_random: i32,
    pub version_renderer: i32,
    pub count_max_particle: i32,
    pub count_frame_per_second: i32,
    pub scale_layout: Option<flatbuffers::WIPOffset<Vector2<'a>>>,
    pub table_parts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataEffectParts<'a>>>>>,
    pub table_emitter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataEffectEmitter<'a>>>>>,
    pub table_index_emitter_order_draw: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for DataEffectArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataEffectArgs {
      version: 0,
      name: None,
      flag_data: 0,
      seed_random: 0,
      version_renderer: 0,
      count_max_particle: 0,
      count_frame_per_second: 0,
      scale_layout: None,
      table_parts: None,
      table_emitter: None,
      table_index_emitter_order_draw: None,
    }
  }
}

pub struct DataEffectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataEffectBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(DataEffect::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataEffect::VT_NAME, name);
  }
  #[inline]
  pub fn add_flag_data(&mut self, flag_data: i32) {
    self.fbb_.push_slot::<i32>(DataEffect::VT_FLAG_DATA, flag_data, 0);
  }
  #[inline]
  pub fn add_seed_random(&mut self, seed_random: i32) {
    self.fbb_.push_slot::<i32>(DataEffect::VT_SEED_RANDOM, seed_random, 0);
  }
  #[inline]
  pub fn add_version_renderer(&mut self, version_renderer: i32) {
    self.fbb_.push_slot::<i32>(DataEffect::VT_VERSION_RENDERER, version_renderer, 0);
  }
  #[inline]
  pub fn add_count_max_particle(&mut self, count_max_particle: i32) {
    self.fbb_.push_slot::<i32>(DataEffect::VT_COUNT_MAX_PARTICLE, count_max_particle, 0);
  }
  #[inline]
  pub fn add_count_frame_per_second(&mut self, count_frame_per_second: i32) {
    self.fbb_.push_slot::<i32>(DataEffect::VT_COUNT_FRAME_PER_SECOND, count_frame_per_second, 0);
  }
  #[inline]
  pub fn add_scale_layout(&mut self, scale_layout: flatbuffers::WIPOffset<Vector2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vector2>>(DataEffect::VT_SCALE_LAYOUT, scale_layout);
  }
  #[inline]
  pub fn add_table_parts(&mut self, table_parts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataEffectParts<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataEffect::VT_TABLE_PARTS, table_parts);
  }
  #[inline]
  pub fn add_table_emitter(&mut self, table_emitter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataEffectEmitter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataEffect::VT_TABLE_EMITTER, table_emitter);
  }
  #[inline]
  pub fn add_table_index_emitter_order_draw(&mut self, table_index_emitter_order_draw: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataEffect::VT_TABLE_INDEX_EMITTER_ORDER_DRAW, table_index_emitter_order_draw);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataEffectBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataEffectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataEffect<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataEffect<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataEffect");
      ds.field("version", &self.version());
      ds.field("name", &self.name());
      ds.field("flag_data", &self.flag_data());
      ds.field("seed_random", &self.seed_random());
      ds.field("version_renderer", &self.version_renderer());
      ds.field("count_max_particle", &self.count_max_particle());
      ds.field("count_frame_per_second", &self.count_frame_per_second());
      ds.field("scale_layout", &self.scale_layout());
      ds.field("table_parts", &self.table_parts());
      ds.field("table_emitter", &self.table_emitter());
      ds.field("table_index_emitter_order_draw", &self.table_index_emitter_order_draw());
      ds.finish()
  }
}
pub enum DataSequenceDetailsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataSequenceDetails<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataSequenceDetails<'a> {
  type Inner = DataSequenceDetails<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataSequenceDetails<'a> {
  pub const VT_REFANIMEPACK: flatbuffers::VOffsetT = 4;
  pub const VT_REFANIME: flatbuffers::VOffsetT = 6;
  pub const VT_REPEATCOUNT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataSequenceDetails { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataSequenceDetailsArgs<'args>
  ) -> flatbuffers::WIPOffset<DataSequenceDetails<'bldr>> {
    let mut builder = DataSequenceDetailsBuilder::new(_fbb);
    builder.add_repeatCount(args.repeatCount);
    if let Some(x) = args.refAnime { builder.add_refAnime(x); }
    if let Some(x) = args.refAnimePack { builder.add_refAnimePack(x); }
    builder.finish()
  }


  #[inline]
  pub fn refAnimePack(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataSequenceDetails::VT_REFANIMEPACK, None)}
  }
  #[inline]
  pub fn refAnime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataSequenceDetails::VT_REFANIME, None)}
  }
  #[inline]
  pub fn repeatCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataSequenceDetails::VT_REPEATCOUNT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DataSequenceDetails<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("refAnimePack", Self::VT_REFANIMEPACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("refAnime", Self::VT_REFANIME, false)?
     .visit_field::<i32>("repeatCount", Self::VT_REPEATCOUNT, false)?
     .finish();
    Ok(())
  }
}
pub struct DataSequenceDetailsArgs<'a> {
    pub refAnimePack: Option<flatbuffers::WIPOffset<&'a str>>,
    pub refAnime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub repeatCount: i32,
}
impl<'a> Default for DataSequenceDetailsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataSequenceDetailsArgs {
      refAnimePack: None,
      refAnime: None,
      repeatCount: 0,
    }
  }
}

pub struct DataSequenceDetailsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataSequenceDetailsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_refAnimePack(&mut self, refAnimePack: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataSequenceDetails::VT_REFANIMEPACK, refAnimePack);
  }
  #[inline]
  pub fn add_refAnime(&mut self, refAnime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataSequenceDetails::VT_REFANIME, refAnime);
  }
  #[inline]
  pub fn add_repeatCount(&mut self, repeatCount: i32) {
    self.fbb_.push_slot::<i32>(DataSequenceDetails::VT_REPEATCOUNT, repeatCount, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataSequenceDetailsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataSequenceDetailsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataSequenceDetails<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataSequenceDetails<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataSequenceDetails");
      ds.field("refAnimePack", &self.refAnimePack());
      ds.field("refAnime", &self.refAnime());
      ds.field("repeatCount", &self.repeatCount());
      ds.finish()
  }
}
pub enum DataSequenceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataSequence<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataSequence<'a> {
  type Inner = DataSequence<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataSequence<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_INDEX: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
  pub const VT_VALUELIST: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataSequence { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataSequenceArgs<'args>
  ) -> flatbuffers::WIPOffset<DataSequence<'bldr>> {
    let mut builder = DataSequenceBuilder::new(_fbb);
    if let Some(x) = args.valueList { builder.add_valueList(x); }
    builder.add_type_(args.type_);
    builder.add_index(args.index);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataSequence::VT_NAME, None)}
  }
  #[inline]
  pub fn index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataSequence::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataSequence::VT_TYPE_, Some(0)).unwrap()}
  }
  #[inline]
  pub fn valueList(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataSequenceDetails<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataSequenceDetails>>>>(DataSequence::VT_VALUELIST, None)}
  }
}

impl flatbuffers::Verifiable for DataSequence<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<i32>("index", Self::VT_INDEX, false)?
     .visit_field::<i32>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataSequenceDetails>>>>("valueList", Self::VT_VALUELIST, false)?
     .finish();
    Ok(())
  }
}
pub struct DataSequenceArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub index: i32,
    pub type_: i32,
    pub valueList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataSequenceDetails<'a>>>>>,
}
impl<'a> Default for DataSequenceArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataSequenceArgs {
      name: None,
      index: 0,
      type_: 0,
      valueList: None,
    }
  }
}

pub struct DataSequenceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataSequenceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataSequence::VT_NAME, name);
  }
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(DataSequence::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: i32) {
    self.fbb_.push_slot::<i32>(DataSequence::VT_TYPE_, type_, 0);
  }
  #[inline]
  pub fn add_valueList(&mut self, valueList: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataSequenceDetails<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataSequence::VT_VALUELIST, valueList);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataSequenceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataSequenceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataSequence<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataSequence<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataSequence");
      ds.field("name", &self.name());
      ds.field("index", &self.index());
      ds.field("type_", &self.type_());
      ds.field("valueList", &self.valueList());
      ds.finish()
  }
}
pub enum SequencePackOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SequencePack<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SequencePack<'a> {
  type Inner = SequencePack<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SequencePack<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_SEQUENCELIST: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SequencePack { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SequencePackArgs<'args>
  ) -> flatbuffers::WIPOffset<SequencePack<'bldr>> {
    let mut builder = SequencePackBuilder::new(_fbb);
    if let Some(x) = args.sequenceList { builder.add_sequenceList(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_version(args.version);
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SequencePack::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SequencePack::VT_NAME, None)}
  }
  #[inline]
  pub fn sequenceList(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataSequence<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataSequence>>>>(SequencePack::VT_SEQUENCELIST, None)}
  }
}

impl flatbuffers::Verifiable for SequencePack<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataSequence>>>>("sequenceList", Self::VT_SEQUENCELIST, false)?
     .finish();
    Ok(())
  }
}
pub struct SequencePackArgs<'a> {
    pub version: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sequenceList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataSequence<'a>>>>>,
}
impl<'a> Default for SequencePackArgs<'a> {
  #[inline]
  fn default() -> Self {
    SequencePackArgs {
      version: 0,
      name: None,
      sequenceList: None,
    }
  }
}

pub struct SequencePackBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SequencePackBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(SequencePack::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SequencePack::VT_NAME, name);
  }
  #[inline]
  pub fn add_sequenceList(&mut self, sequenceList: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataSequence<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SequencePack::VT_SEQUENCELIST, sequenceList);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SequencePackBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SequencePackBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SequencePack<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SequencePack<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SequencePack");
      ds.field("version", &self.version());
      ds.field("name", &self.name());
      ds.field("sequenceList", &self.sequenceList());
      ds.finish()
  }
}
pub enum ProjectDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ProjectData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProjectData<'a> {
  type Inner = ProjectData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ProjectData<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_CELL_MAP: flatbuffers::VOffsetT = 8;
  pub const VT_ANIMATION: flatbuffers::VOffsetT = 10;
  pub const VT_EFFECT: flatbuffers::VOffsetT = 12;
  pub const VT_SEQUENCE: flatbuffers::VOffsetT = 14;
  pub const VT_NAME_TEXTURE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ProjectData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProjectDataArgs<'args>
  ) -> flatbuffers::WIPOffset<ProjectData<'bldr>> {
    let mut builder = ProjectDataBuilder::new(_fbb);
    if let Some(x) = args.name_texture { builder.add_name_texture(x); }
    if let Some(x) = args.sequence { builder.add_sequence(x); }
    if let Some(x) = args.effect { builder.add_effect(x); }
    if let Some(x) = args.animation { builder.add_animation(x); }
    if let Some(x) = args.cell_map { builder.add_cell_map(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_version(args.version);
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ProjectData::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProjectData::VT_NAME, None)}
  }
  #[inline]
  pub fn cell_map(&self) -> Option<DataCellMap<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DataCellMap>>(ProjectData::VT_CELL_MAP, None)}
  }
  #[inline]
  pub fn animation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataAnimation<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataAnimation>>>>(ProjectData::VT_ANIMATION, None)}
  }
  #[inline]
  pub fn effect(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataEffect<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataEffect>>>>(ProjectData::VT_EFFECT, None)}
  }
  #[inline]
  pub fn sequence(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SequencePack<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SequencePack>>>>(ProjectData::VT_SEQUENCE, None)}
  }
  #[inline]
  pub fn name_texture(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ProjectData::VT_NAME_TEXTURE, None)}
  }
}

impl flatbuffers::Verifiable for ProjectData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DataCellMap>>("cell_map", Self::VT_CELL_MAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataAnimation>>>>("animation", Self::VT_ANIMATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataEffect>>>>("effect", Self::VT_EFFECT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SequencePack>>>>("sequence", Self::VT_SEQUENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("name_texture", Self::VT_NAME_TEXTURE, false)?
     .finish();
    Ok(())
  }
}
pub struct ProjectDataArgs<'a> {
    pub version: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cell_map: Option<flatbuffers::WIPOffset<DataCellMap<'a>>>,
    pub animation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataAnimation<'a>>>>>,
    pub effect: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataEffect<'a>>>>>,
    pub sequence: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SequencePack<'a>>>>>,
    pub name_texture: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ProjectDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    ProjectDataArgs {
      version: 0,
      name: None,
      cell_map: None,
      animation: None,
      effect: None,
      sequence: None,
      name_texture: None,
    }
  }
}

pub struct ProjectDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProjectDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(ProjectData::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProjectData::VT_NAME, name);
  }
  #[inline]
  pub fn add_cell_map(&mut self, cell_map: flatbuffers::WIPOffset<DataCellMap<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DataCellMap>>(ProjectData::VT_CELL_MAP, cell_map);
  }
  #[inline]
  pub fn add_animation(&mut self, animation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataAnimation<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProjectData::VT_ANIMATION, animation);
  }
  #[inline]
  pub fn add_effect(&mut self, effect: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataEffect<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProjectData::VT_EFFECT, effect);
  }
  #[inline]
  pub fn add_sequence(&mut self, sequence: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SequencePack<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProjectData::VT_SEQUENCE, sequence);
  }
  #[inline]
  pub fn add_name_texture(&mut self, name_texture: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProjectData::VT_NAME_TEXTURE, name_texture);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProjectDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProjectDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProjectData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ProjectData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ProjectData");
      ds.field("version", &self.version());
      ds.field("name", &self.name());
      ds.field("cell_map", &self.cell_map());
      ds.field("animation", &self.animation());
      ds.field("effect", &self.effect());
      ds.field("sequence", &self.sequence());
      ds.field("name_texture", &self.name_texture());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ProjectData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_project_data_unchecked`.
pub fn root_as_project_data(buf: &[u8]) -> Result<ProjectData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ProjectData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ProjectData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_project_data_unchecked`.
pub fn size_prefixed_root_as_project_data(buf: &[u8]) -> Result<ProjectData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ProjectData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ProjectData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_project_data_unchecked`.
pub fn root_as_project_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ProjectData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ProjectData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ProjectData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_project_data_unchecked`.
pub fn size_prefixed_root_as_project_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ProjectData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ProjectData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ProjectData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ProjectData`.
pub unsafe fn root_as_project_data_unchecked(buf: &[u8]) -> ProjectData {
  flatbuffers::root_unchecked::<ProjectData>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ProjectData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ProjectData`.
pub unsafe fn size_prefixed_root_as_project_data_unchecked(buf: &[u8]) -> ProjectData {
  flatbuffers::size_prefixed_root_unchecked::<ProjectData>(buf)
}
pub const PROJECT_DATA_IDENTIFIER: &str = "SFB2";

#[inline]
pub fn project_data_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PROJECT_DATA_IDENTIFIER, false)
}

#[inline]
pub fn project_data_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PROJECT_DATA_IDENTIFIER, true)
}

#[inline]
pub fn finish_project_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ProjectData<'a>>) {
  fbb.finish(root, Some(PROJECT_DATA_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_project_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ProjectData<'a>>) {
  fbb.finish_size_prefixed(root, Some(PROJECT_DATA_IDENTIFIER));
}
}  // pub mod ssfb2
}  // pub mod ss

